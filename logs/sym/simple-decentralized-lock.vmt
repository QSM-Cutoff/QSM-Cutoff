(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))

(declare-fun __has_lock (node) Bool)
(declare-fun __message (node node) Bool)
(declare-fun __start_node () node)

(declare-fun has_lock (node) Bool)
(declare-fun message (node node) Bool)
(declare-fun start_node () node)

(define-fun .has_lock ((V0 node)) Bool (! (__has_lock V0) :next has_lock))
(define-fun .message ((V0 node) (V1 node)) Bool (! (__message V0 V1) :next message))
(define-fun .start_node () node (! __start_node :next start_node))

(define-fun .prop () Bool (! 
 (let (($v (forall ((X node) (Y node)) (=> (not (= X Y)) (not (and (__has_lock X) (__has_lock Y)))))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v (and (forall ((V0 node) (V1 node)) (= (__message V0 V1) false)) (forall ((V0 node)) (= (__has_lock V0) (= V0 __start_node))))
 ))
 (and $v))
 :init true))

(declare-fun recv (node node) Bool)
(define-fun .recv ((V0 node) (V1 node)) Bool (! (recv V0 V1) :action true))

(declare-fun send (node node) Bool)
(define-fun .send ((V0 node) (V1 node)) Bool (! (send V0 V1) :action true))


