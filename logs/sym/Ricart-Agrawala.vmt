(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))

(declare-fun __holds (node) Bool)
(declare-fun __replied (node node) Bool)
(declare-fun __requested (node node) Bool)

(declare-fun holds (node) Bool)
(declare-fun replied (node node) Bool)
(declare-fun requested (node node) Bool)

(define-fun .holds ((V0 node)) Bool (! (__holds V0) :next holds))
(define-fun .replied ((V0 node) (V1 node)) Bool (! (__replied V0 V1) :next replied))
(define-fun .requested ((V0 node) (V1 node)) Bool (! (__requested V0 V1) :next requested))

(define-fun .prop () Bool (! 
 (let (($v (forall ((N1 node) (N2 node)) (=> (and (__holds N1) (__holds N2)) (= N1 N2)))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v (and (forall ((V0 node) (V1 node)) (= (__requested V0 V1) false)) (forall ((V0 node) (V1 node)) (= (__replied V0 V1) false)) (forall ((V0 node)) (= (__holds V0) false)))
 ))
 (and $v))
 :init true))

(declare-fun enter (node) Bool)
(define-fun .enter ((V0 node)) Bool (! (enter V0) :action true))

(declare-fun leave (node) Bool)
(define-fun .leave ((V0 node)) Bool (! (leave V0) :action true))

(declare-fun reply (node node) Bool)
(define-fun .reply ((V0 node) (V1 node)) Bool (! (reply V0 V1) :action true))

(declare-fun request (node node) Bool)
(define-fun .request ((V0 node) (V1 node)) Bool (! (request V0 V1) :action true))


