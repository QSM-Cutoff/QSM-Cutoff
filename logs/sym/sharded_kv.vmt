(declare-sort key 0)
(declare-sort node 0)
(declare-sort value 0)

(define-fun .key ((S key)) key (! S :sort 0))
(define-fun .node ((S node)) node (! S :sort 0))
(define-fun .value ((S value)) value (! S :sort 0))

(declare-fun __owner (node key) Bool)
(declare-fun __table (node key value) Bool)
(declare-fun __transfer_msg (node key value) Bool)

(declare-fun owner (node key) Bool)
(declare-fun table (node key value) Bool)
(declare-fun transfer_msg (node key value) Bool)

(define-fun .owner ((V0 node) (V1 key)) Bool (! (__owner V0 V1) :next owner))
(define-fun .table ((V0 node) (V1 key) (V2 value)) Bool (! (__table V0 V1 V2) :next table))
(define-fun .transfer_msg ((V0 node) (V1 key) (V2 value)) Bool (! (__transfer_msg V0 V1 V2) :next transfer_msg))

(define-fun .prop () Bool (! 
 (let (($v (forall ((K key) (N1 node) (N2 node) (V1 value) (V2 value)) (=> (and (__table N1 K V1) (__table N2 K V2)) (and (= N1 N2) (= V1 V2))))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v (and (forall ((V0 node) (V1 key) (V2 value)) (= (__table V0 V1 V2) false)) (forall ((V0 node) (V1 key) (V2 value)) (= (__transfer_msg V0 V1 V2) false)) (forall ((K key) (N1 node) (N2 node)) (=> (and (__owner N1 K) (__owner N2 K)) (= N1 N2))))
 ))
 (and $v))
 :init true))

(declare-fun put (node key value) Bool)
(define-fun .put ((V0 node) (V1 key) (V2 value)) Bool (! (put V0 V1 V2) :action true))

(declare-fun recv_transfer_msg (node key value) Bool)
(define-fun .recv_transfer_msg ((V0 node) (V1 key) (V2 value)) Bool (! (recv_transfer_msg V0 V1 V2) :action true))

(declare-fun reshard (key value node node) Bool)
(define-fun .reshard ((V0 key) (V1 value) (V2 node) (V3 node)) Bool (! (reshard V0 V1 V2 V3) :action true))


