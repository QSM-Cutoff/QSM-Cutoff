(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))

(declare-fun __allowed_in (node) Bool)
(declare-fun __internal (node) Bool)
(declare-fun __sent (node node) Bool)

(declare-fun allowed_in (node) Bool)
(declare-fun internal (node) Bool)
(declare-fun sent (node node) Bool)

(define-fun .allowed_in ((V0 node)) Bool (! (__allowed_in V0) :next allowed_in))
(define-fun .internal ((V0 node)) Bool (! (__internal V0) :next internal))
(define-fun .sent ((V0 node) (V1 node)) Bool (! (__sent V0 V1) :next sent))

(define-fun .prop () Bool (! 
 (let (($v (forall ((D node) (S node)) (=> (and (__sent S D) (__internal D)) (exists ((I node)) (and (__internal I) (__sent I S)))))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v (and (forall ((V0 node) (V1 node)) (= (__sent V0 V1) false)) (forall ((V0 node)) (= (__allowed_in V0) false)))
 ))
 (and $v))
 :init true))

(declare-fun send_from_internal (node node) Bool)
(define-fun .send_from_internal ((V0 node) (V1 node)) Bool (! (send_from_internal V0 V1) :action true))

(declare-fun send_to_internal (node node) Bool)
(define-fun .send_to_internal ((V0 node) (V1 node)) Bool (! (send_to_internal V0 V1) :action true))


