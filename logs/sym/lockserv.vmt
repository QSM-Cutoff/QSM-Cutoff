(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))

(declare-fun __grant_msg (node) Bool)
(declare-fun __holds_lock (node) Bool)
(declare-fun __lock_msg (node) Bool)
(declare-fun __server_holds_lock () Bool)
(declare-fun __unlock_msg (node) Bool)

(declare-fun grant_msg (node) Bool)
(declare-fun holds_lock (node) Bool)
(declare-fun lock_msg (node) Bool)
(declare-fun server_holds_lock () Bool)
(declare-fun unlock_msg (node) Bool)

(define-fun .grant_msg ((V0 node)) Bool (! (__grant_msg V0) :next grant_msg))
(define-fun .holds_lock ((V0 node)) Bool (! (__holds_lock V0) :next holds_lock))
(define-fun .lock_msg ((V0 node)) Bool (! (__lock_msg V0) :next lock_msg))
(define-fun .server_holds_lock () Bool (! __server_holds_lock :next server_holds_lock))
(define-fun .unlock_msg ((V0 node)) Bool (! (__unlock_msg V0) :next unlock_msg))

(define-fun .prop () Bool (! 
 (let (($v (forall ((N1 node) (N2 node)) (=> (and (__holds_lock N1) (__holds_lock N2)) (= N1 N2)))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v (and (forall ((V0 node)) (= (__lock_msg V0) false)) (forall ((V0 node)) (= (__grant_msg V0) false)) (forall ((V0 node)) (= (__unlock_msg V0) false)) (forall ((V0 node)) (= (__holds_lock V0) false)) (= __server_holds_lock true))
 ))
 (and $v))
 :init true))

(declare-fun recv_grant (node) Bool)
(define-fun .recv_grant ((V0 node)) Bool (! (recv_grant V0) :action true))

(declare-fun recv_lock (node) Bool)
(define-fun .recv_lock ((V0 node)) Bool (! (recv_lock V0) :action true))

(declare-fun recv_unlock (node) Bool)
(define-fun .recv_unlock ((V0 node)) Bool (! (recv_unlock V0) :action true))

(declare-fun send_lock (node) Bool)
(define-fun .send_lock ((V0 node)) Bool (! (send_lock V0) :action true))

(declare-fun unlock (node) Bool)
(define-fun .unlock ((V0 node)) Bool (! (unlock V0) :action true))


