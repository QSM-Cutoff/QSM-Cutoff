(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))

(declare-fun __grant_msg (node) Bool)
(declare-fun __held () Bool)
(declare-fun __holds_lock (node) Bool)
(declare-fun __lock_msg (node) Bool)
(declare-fun __unlock_msg (node) Bool)

(declare-fun grant_msg (node) Bool)
(declare-fun held () Bool)
(declare-fun holds_lock (node) Bool)
(declare-fun lock_msg (node) Bool)
(declare-fun unlock_msg (node) Bool)

(define-fun .grant_msg ((V0 node)) Bool (! (__grant_msg V0) :next grant_msg))
(define-fun .held () Bool (! __held :next held))
(define-fun .holds_lock ((V0 node)) Bool (! (__holds_lock V0) :next holds_lock))
(define-fun .lock_msg ((V0 node)) Bool (! (__lock_msg V0) :next lock_msg))
(define-fun .unlock_msg ((V0 node)) Bool (! (__unlock_msg V0) :next unlock_msg))

(define-fun .prop () Bool (! 
 (let (($v (forall ((X node) (Y node)) (=> (and (__holds_lock X) (__holds_lock Y)) (= X Y)))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v (and (forall ((V0 node)) (= (__lock_msg V0) false)) (forall ((V0 node)) (= (__unlock_msg V0) false)) (forall ((V0 node)) (= (__grant_msg V0) false)) (forall ((V0 node)) (= (__holds_lock V0) false)) (= __held false))
 ))
 (and $v))
 :init true))

(declare-fun lock (node) Bool)
(define-fun .lock ((V0 node)) Bool (! (lock V0) :action true))

(declare-fun recv_grant (node) Bool)
(define-fun .recv_grant ((V0 node)) Bool (! (recv_grant V0) :action true))

(declare-fun recv_lock (node) Bool)
(define-fun .recv_lock ((V0 node)) Bool (! (recv_lock V0) :action true))

(declare-fun recv_unlock (node) Bool)
(define-fun .recv_unlock ((V0 node)) Bool (! (recv_unlock V0) :action true))

(declare-fun unlock (node) Bool)
(define-fun .unlock ((V0 node)) Bool (! (unlock V0) :action true))


