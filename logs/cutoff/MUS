./Consensus.cutoff.log:[UNSAT CORE]:                     ((forall VALUE1,VALUE0. ~chosen(VALUE0) | ~chosen(VALUE1) | VALUE0 = VALUE1))
./Ricart-Agrawala.cutoff.log:[UNSAT CORE]:               ((forall NODE0,NODE1. ~holds(NODE0) | replied(NODE0,NODE1) | NODE0 = NODE1) 
                                                         & (forall NODE0,NODE1. ~replied(NODE0,NODE1) | ~replied(NODE1,NODE0) | NODE0 = NODE1))
./TCommit.cutoff.log:[UNSAT CORE]:                       ((forall RESOURCE_MANAGER1,RESOURCE_MANAGER0. ~committed(RESOURCE_MANAGER1) | ~aborted(RESOURCE_MANAGER0)))
./TwoPhase.cutoff.log:[UNSAT CORE]:                      ((forall RESOURCE_MANAGER0. msg_prepared(RESOURCE_MANAGER0) | ~tm_prepared(RESOURCE_MANAGER0)) 
                                                         & (~msg_commit | ~msg_abort) 
                                                         & (forall RESOURCE_MANAGER0. msg_commit | ~committed(RESOURCE_MANAGER0)) 
                                                         & (forall RESOURCE_MANAGER0. ~msg_commit | tm_prepared(RESOURCE_MANAGER0)) 
                                                         & (forall RESOURCE_MANAGER0. ~msg_prepared(RESOURCE_MANAGER0) | ~aborted(RESOURCE_MANAGER0) | msg_abort))
./client_server_ae.cutoff.log:[UNSAT CORE]:              ((forall P,N. responseMatched(N,P) <-> (exists R. (request_sent(N,R) & match(R,P)))) 
                                                         & (forall NODE0,RESPONSE0. ~response_received(NODE0,RESPONSE0) | response_sent(NODE0,RESPONSE0)) 
                                                         & (forall NODE0,RESPONSE0. ~response_sent(NODE0,RESPONSE0) | responseMatched(NODE0,RESPONSE0)))
./consensus_epr.cutoff.log:[UNSAT CORE]:                 ((forall N. chosen(N) <-> (exists Q. (forall Nv. member(Nv,Q) -> votes(N,Nv)))) 
                                                         & (forall VALUE0,NODE1,VALUE1,NODE0. ~decided(NODE0,VALUE0) | ~decided(NODE1,VALUE1) | (NODE0 = NODE1 & VALUE0 = VALUE1)))
./firewal.cutoff.log:[UNSAT CORE]:                       ((forall NODE1. ~allowed_in(NODE1) | (exists NODE0. (sent(NODE0,NODE1) & NODE0 ~= NODE1))) 
                                                         & (forall NODE0. ~internal(NODE0) | ~allowed_in(NODE0)) 
                                                         & (forall NODE0,NODE1. internal(NODE1) | internal(NODE0) | ~sent(NODE0,NODE1) | NODE0 = NODE1) 
                                                         & (forall NODE0,NODE1. allowed_in(NODE1) | allowed_in(NODE0) | ~sent(NODE0,NODE1) | NODE0 = NODE1))
./lock_server.cutoff.log:[UNSAT CORE]:                   ((forall SERVER0,CLIENT0,CLIENT1. ~link(CLIENT1,SERVER0) | ~link(CLIENT0,SERVER0) | CLIENT0 = CLIENT1))
./lockser.cutoff.log:[UNSAT CORE]:                       ((forall NODE1,NODE0. ~holds_lock(NODE1) | ~holds_lock(NODE0) | NODE0 = NODE1))
./lockserv_automaton.cutoff.log:[UNSAT CORE]:            ((forall NODE1,NODE0. ~holds_lock(NODE0) | ~holds_lock(NODE1) | NODE0 = NODE1))
./naive_consensus.cutoff.log:[UNSAT CORE]:               ((forall Q2,Q1. (exists N. (member(N,Q1) & member(N,Q2)))) 
                                                         & (forall VALUE0,NODE0,VALUE1. ~vote(NODE0,VALUE0) | ~vote(NODE0,VALUE1) | VALUE0 = VALUE1) 
                                                         & (forall VALUE0. (exists QUORUM0. decide(QUORUM0,VALUE0) | ~decision(VALUE0))) 
                                                         & (forall VALUE0,NODE0,QUORUM0. vote(NODE0,VALUE0) | ~member(NODE0,QUORUM0) | ~decide(QUORUM0,VALUE0)))
./quorum-leader-election-wo-maj.cutoff.log:[UNSAT CORE]: ((forall S2,S1. (exists N. (member(N,S1) & member(N,S2)))) 
                                                         & (forall NODE2,NODE1,NODE0. ~voted(NODE0,NODE2) | ~voted(NODE0,NODE1) | ((NODE1 = NODE2 & NODE0 ~= NODE1) | (NODE0 = NODE2 & NODE0 = NODE1))) 
                                                         & (forall NODE1,NSET0,NODE0. voted(NODE1,NODE0) | quorum ~= NSET0 | ~isleader(NODE0) | ((NODE0 ~= NODE1 | ~member(NODE0,NSET0)) & (NODE0 = NODE1 | ~member(NODE0,NSET0) | ~member(NODE1,NSET0)) & (NODE0 = NODE1 | ~member(NODE1,NSET0) | member(NODE0,NSET0)))))
./sharded_kv.cutoff.log:[UNSAT CORE]:                    ((forall KEY0,VALUE1,NODE1,NODE0,VALUE0. ~table(NODE1,KEY0,VALUE1) | ~table(NODE0,KEY0,VALUE0) | (NODE0 = NODE1 & VALUE0 = VALUE1)))
./sharded_kv_no_lost_keys.cutoff.log:[UNSAT CORE]:       ((forall KEY0. (exists NODE0,VALUE0. transfer_msg(NODE0,KEY0,VALUE0) | owner(NODE0,KEY0))))
./simple-decentralized-lock.cutoff.log:[UNSAT CORE]:     ((forall NODE0,NODE1. ~has_lock(NODE1) | ~has_lock(NODE0) | NODE0 = NODE1))
./simple-election.cutoff.log:[UNSAT CORE]:               ((forall A. didNotPromise(A) <-> (forall P. ~promise(A,P))) 
                                                         & (forall P,Q. chosenAt(Q,P) <-> (forall A. member(A,Q) -> promise(A,P))) 
                                                         & (forall Q2,Q1. (exists A. (member(A,Q1) & member(A,Q2)))) 
                                                         & (forall PROPOSER1,ACCEPTOR0,PROPOSER0. ~promise(ACCEPTOR0,PROPOSER0) | ~promise(ACCEPTOR0,PROPOSER1) | PROPOSER0 = PROPOSER1) 
                                                         & (forall PROPOSER0. (exists QUORUM0. ~leader(PROPOSER0) | chosenAt(QUORUM0,PROPOSER0))))
./toy_consensus.cutoff.log:[UNSAT CORE]:                 ((forall N. didNotVote(N) <-> (forall V. ~vote(N,V))) 
                                                         & (forall V,Q. chosenAt(Q,V) <-> (forall N. member(N,Q) -> vote(N,V))) 
                                                         & (forall Q2,Q1. (exists N. (member(N,Q1) & member(N,Q2)))) 
                                                         & (forall NODE0,VALUE1,VALUE0. ~vote(NODE0,VALUE1) | ~vote(NODE0,VALUE0) | VALUE0 = VALUE1) 
                                                         & (forall VALUE0. (exists QUORUM0. chosenAt(QUORUM0,VALUE0) | ~decision(VALUE0))))
./toy_consensus_epr.cutoff.log:[UNSAT CORE]:             ((forall V,Q. chosenAt(Q,V) <-> (forall N. member(N,Q) -> vote(N,V))) 
                                                         & (forall Q2,Q1. (exists N. (member(N,Q1) & member(N,Q2)))) 
                                                         & (forall VALUE1,VALUE0,NODE0. ~vote(NODE0,VALUE0) | ~vote(NODE0,VALUE1) | VALUE0 = VALUE1) 
                                                         & (forall VALUE0. (exists QUORUM0. chosenAt(QUORUM0,VALUE0) | ~decided(VALUE0))))
./toy_consensus_forall.cutoff.log:[UNSAT CORE]:          ((forall Q1,Q2. (exists N. (member(N,Q1) & member(N,Q2)))) 
                                                         & (forall VALUE1,NODE0,VALUE0. ~vote(NODE0,VALUE0) | ~vote(NODE0,VALUE1) | VALUE0 = VALUE1) 
                                                         & (forall QUORUM0,NODE0,VALUE0. ~member(NODE0,QUORUM0) | ~decided(VALUE0) | vote(NODE0,VALUE0) | voting_quorum ~= QUORUM0))