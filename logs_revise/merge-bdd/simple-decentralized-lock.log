
*************************************************************************

	[QRM]: ivybench/sym/ivy/simple-decentralized-lock.ivy

*************************************************************************


***********************************************************************************************

	[Synthesize Rmin]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

***********************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.ivy -s node=1 -f 1 -g -w -r -b -e -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


=====================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=====================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 3

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 1

[QRM NOTE]: Time elapsed since start: 0.020 seconds

[QRM NOTE]: Time elapsed since last: 0.020 seconds

[QRM NOTE]: Peak memory: 19935 bytes


===================================

	Forward reachability

===================================

building bdd for atoms

building bdd for initial action

building bdd for axioms

building bdd for actions

building bdd for action: send(fml:src,fml:dst)

building bdd for action: recv(fml:src,fml:dst)

building bdd for abstractions

start symbolic image computation

start extracting cubes

[FW NOTE]: number of reachable cubes: 2


========================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock: node=1]

========================================================================================================

sort: node=['node0']
predicate: message('node', 'node')
predicate: start_node=('node',)
predicate: has_lock('node',)
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'message(node0,node0)', '(start_node=node0)']

011
101

[QRM NOTE]: Time elapsed since start: 0.054 seconds

[QRM NOTE]: Time elapsed since last: 0.033 seconds

[QRM NOTE]: Peak memory: 1079840 bytes


======================================

	Reduce Equivalent Atoms

======================================

[FW NOTE]: equivalent atoms

[FW NOTE]: complement atoms

[FW NOTE]: remove_atom_ids: set()

[QRM NOTE]: Time elapsed since start: 0.057 seconds

[QRM NOTE]: Time elapsed since last: 0.003 seconds

[QRM NOTE]: Peak memory: 30983 bytes


============================================================================================================

	[PRIME]: Prime Orbit Generatation on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

============================================================================================================


=======================================================================================================

	[PRIME RESULT]: Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=======================================================================================================


=== Prime Orbit 0 =====================
size : 1
num_suborbits: 1
0 (*) : --0
0     : ['~(start_node=node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 1 =====================
size : 1
num_suborbits: 1
1 (*) : 00-
1     : ['~has_lock(node0)', '~message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 2 =====================
size : 1
num_suborbits: 1
2 (*) : 11-
2     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0



[PRIME NOTE]: number of orbits after merging: 3

[PRIME NOTE]: number of orbits before merging: 3

[PRIME NOTE]: number of primes: 3

[QRM NOTE]: Time elapsed since start: 0.067 seconds

[QRM NOTE]: Time elapsed since last: 0.010 seconds

[QRM NOTE]: Peak memory: 1087509 bytes


=================================================================================================

	[RED]: PRIME REDUCTION on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=================================================================================================

definition primes: {0}


New level: 0
 pending : [1, 2]
 solution : []


Before reduction : 
 pending  : [1, 2]
 solution : []

Essensial at level 0 : {1, 2}

Before removed
 coverage : [(0, -1), (1, -1), (2, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2]


Before reduction : 
 pending  : []
 solution : [1, 2]

Essensial at level 0 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2]

[QRM NOTE]: Time elapsed since start: 0.068 seconds

[QRM NOTE]: Time elapsed since last: 0.001 seconds

[QRM NOTE]: Peak memory: 39611 bytes


=====================================================================================================

	[QI]: Quantifier Inference on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=====================================================================================================


---------- quantifier_inference ----------


=== Prime Orbit 1 =====================
size : 1
num_suborbits: 1
1 (*) : 00-
1     : ['~has_lock(node0)', '~message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['~has_lock(node0)', '~message(node0,node0)']

sign_func_name2args: {'1$has_lock': [(Const('node0', EnumeratedSort('node', ('node0',))),)], '1$message': [(Const('node0', EnumeratedSort('node', ('node0',))), Const('node0', EnumeratedSort('node', ('node0',))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0',))): [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$1$0]}

sig2const: {'node$1$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0',))), 'node$1$message$0$0': Const('node0', EnumeratedSort('node', ('node0',))), 'node$1$message$1$0': Const('node0', EnumeratedSort('node', ('node0',)))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0',)): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0',)): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0}

part_sig: ('node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0',)


---------- SigGenerator ----------

terms:  ['~has_lock(node0)', '~message(node0,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0',)), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0',)), EnumeratedSort('node', ('node0',)), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0',)),), 'message': (EnumeratedSort('node', ('node0',)), EnumeratedSort('node', ('node0',)))}

sign_func_name2count:  {'1$has_lock': 1, '1$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0',)): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0',)): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0}

	sort: node

	identical_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$1': [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0]}

	identical_single_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$1': node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0',)))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'1$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0',)))]], '1$message': [[Var('NODE0', EnumeratedSort('node', ('node0',))), Var('NODE0', EnumeratedSort('node', ('node0',)))]]}


---------- QFormula: _set_qterms ----------

qterms: ['~message(NODE0,NODE0)', '~has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0. message(NODE0,NODE0) | has_lock(NODE0)


=== Prime Orbit 2 =====================
size : 1
num_suborbits: 1
2 (*) : 11-
2     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node0,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0',))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0',))), Const('node0', EnumeratedSort('node', ('node0',))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0',))): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0',))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0',))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0',)))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0',)): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0',)): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node0,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0',)), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0',)), EnumeratedSort('node', ('node0',)), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0',)),), 'message': (EnumeratedSort('node', ('node0',)), EnumeratedSort('node', ('node0',)))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0',)): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0',)): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0',)))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0',)))]], '0$message': [[Var('NODE0', EnumeratedSort('node', ('node0',))), Var('NODE0', EnumeratedSort('node', ('node0',)))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'message(NODE0,NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE0)


===============================================================================================================

	[QI RESULT]: Quantified Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

===============================================================================================================


=== Prime Orbit 1 =====================
size : 1
num_suborbits: 1
1 (*) : 00-
1     : ['~has_lock(node0)', '~message(node0,node0)']
num_forall :   1
num_exists :   0
num_literals : 2
quantified form : forall NODE0. message(NODE0,NODE0) | has_lock(NODE0)
qcost : 3




=== Prime Orbit 2 =====================
size : 1
num_suborbits: 1
2 (*) : 11-
2     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   1
num_exists :   0
num_literals : 2
quantified form : forall NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE0)
qcost : 3



[QRM NOTE]: Time elapsed since start: 0.132 seconds

[QRM NOTE]: Time elapsed since last: 0.064 seconds

[QRM NOTE]: Peak memory: 1772029 bytes


==============================================================================================

	[MIN]: Minimization on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

==============================================================================================


New level: 1
 pending : []
 solution : [1, 2]


Before reduction : 
 pending  : []
 solution : [1, 2]

Essensial at level 1 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1)]

Covered at level 1 : set()

After reduction : 
 pending  : []
 solution : [1, 2]


Solution : [1, 2] has cost 6.


Before backtrack at level 1
 pending : []
 solution : [1, 2]

After backtrack at level 1
 pending : []
 solution : [1, 2]


=============================================================================================================

	[MIN RESULT]: Minimized Invariants on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=============================================================================================================

[MIN NOTE]: number of minimal solution found: 1

[MIN NOTE]: upper bound: 6

[MIN NOTE]: maximum branch and bound depth: 1

[MIN NOTE]: number of definitions: 0

[MIN NOTE]: number of equality relations: 0

[MIN NOTE]: Solution 0 : [1, 2]

[MIN NOTE]: solution length: 2

invariant [invar_1] forall NODE0. message(NODE0,NODE0) | has_lock(NODE0) # qcost: 3

invariant [invar_2] forall NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE0) # qcost: 3

[MIN NOTE]: number of total invariants: 2

[MIN NOTE]: total qCost: 6




[QRM NOTE]: Time elapsed since start: 0.201 seconds

[QRM NOTE]: Time elapsed since last: 0.069 seconds

[QRM NOTE]: Peak memory: 1761820 bytes


**************************************************************************************************************

	[Reachability Convergence Check]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

**************************************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.node_1.0.ivy -s node=2 -f 2 -g -w -r -b -e -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


==============================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_1.0.ivy: node=2]

==============================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 8

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 2

[QRM NOTE]: Time elapsed since start: 0.034 seconds

[QRM NOTE]: Time elapsed since last: 0.034 seconds

[QRM NOTE]: Peak memory: 64295 bytes


===================================

	Forward reachability

===================================

building bdd for atoms

building bdd for initial action

building bdd for axioms

building bdd for actions

building bdd for action: send(fml:src,fml:dst)

building bdd for action: recv(fml:src,fml:dst)

building bdd for abstractions

start symbolic image computation

start extracting cubes

[FW NOTE]: number of reachable cubes: 12


========================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock: node=2]

========================================================================================================

sort: node=['node0', 'node1']
predicate: has_lock('node',)
predicate: message('node', 'node')
predicate: start_node=('node',)
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'has_lock(node1)', 'message(node0,node0)', 'message(node0,node1)', 'message(node1,node0)', 'message(node1,node1)', '(start_node=node0)', '(start_node=node1)']

00000101
00000110
00001001
00001010
00010001
00010010
00100001
00100010
01000001
01000010
10000001
10000010

[QRM NOTE]: Time elapsed since start: 0.212 seconds

[QRM NOTE]: Time elapsed since last: 0.178 seconds

[QRM NOTE]: Peak memory: 1153587 bytes


==========================================================================================================================================

	[REACH_CHECK]: Reachability Convergence Check for Rmin on [ivybench/sym/ivy/simple-decentralized-lock.node_1.0.ivy: node=2]

==========================================================================================================================================

[REACH_CHECK RESULT]: FAIL

[QRM NOTE]: Time elapsed since start: 0.257 seconds

[QRM NOTE]: Time elapsed since last: 0.044 seconds

[QRM NOTE]: Peak memory: 142517 bytes

next size: node=2


***********************************************************************************************

	[Synthesize Rmin]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

***********************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.ivy -s node=2 -f 1 -g -w -r -b -e -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


---------- Initializing reachability from file ----------

OK


======================================

	Reduce Equivalent Atoms

======================================

[FW NOTE]: equivalent atoms

[FW NOTE]: complement atoms

[FW NOTE]: remove_atom_ids: set()

[QRM NOTE]: Time elapsed since start: 0.017 seconds

[QRM NOTE]: Time elapsed since last: 0.017 seconds

[QRM NOTE]: Peak memory: 3016 bytes


============================================================================================================

	[PRIME]: Prime Orbit Generatation on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

============================================================================================================


=======================================================================================================

	[PRIME RESULT]: Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

=======================================================================================================


=== Prime Orbit 0 =====================
size : 1
num_suborbits: 1
0 (*) : ------00
0     : ['~(start_node=node0)', '~(start_node=node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 1 =====================
size : 6
num_suborbits: 4
1 (*) : ----11--
1     : ['message(node1,node0)', 'message(node1,node1)']
2     : --11----
2     : ['message(node0,node0)', 'message(node0,node1)']
7 (*) : --1-1---
7     : ['message(node0,node0)', 'message(node1,node0)']
8     : ---1-1--
8     : ['message(node0,node1)', 'message(node1,node1)']
9 (*) : ---11---
9     : ['message(node0,node1)', 'message(node1,node0)']
16 (*) : --1--1--
16     : ['message(node0,node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 2 =====================
size : 8
num_suborbits: 4
3 (*) : -1--1---
3     : ['has_lock(node1)', 'message(node1,node0)']
4     : 1--1----
4     : ['has_lock(node0)', 'message(node0,node1)']
5 (*) : 1---1---
5     : ['has_lock(node0)', 'message(node1,node0)']
6     : -1-1----
6     : ['has_lock(node1)', 'message(node0,node1)']
12 (*) : 1-1-----
12     : ['has_lock(node0)', 'message(node0,node0)']
13     : -1---1--
13     : ['has_lock(node1)', 'message(node1,node1)']
14 (*) : -11-----
14     : ['has_lock(node1)', 'message(node0,node0)']
15     : 1----1--
15     : ['has_lock(node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 3 =====================
size : 1
num_suborbits: 1
10 (*) : ------11
10     : ['(start_node=node0)', '(start_node=node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 4 =====================
size : 1
num_suborbits: 1
11 (*) : 11------
11     : ['has_lock(node0)', 'has_lock(node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
17 (*) : 000000--
17     : ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0



[PRIME NOTE]: number of orbits after merging: 6

[PRIME NOTE]: number of orbits before merging: 12

[PRIME NOTE]: number of primes: 18

[QRM NOTE]: Time elapsed since start: 0.028 seconds

[QRM NOTE]: Time elapsed since last: 0.011 seconds

[QRM NOTE]: Peak memory: 1091471 bytes


=================================================================================================

	[RED]: PRIME REDUCTION on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

=================================================================================================

definition primes: {0, 3}


New level: 0
 pending : [1, 2, 4, 5]
 solution : []


Before reduction : 
 pending  : [1, 2, 4, 5]
 solution : []

Essensial at level 0 : {1, 2, 4, 5}

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 4, 5]


Before reduction : 
 pending  : []
 solution : [1, 2, 4, 5]

Essensial at level 0 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 4, 5]

[QRM NOTE]: Time elapsed since start: 0.029 seconds

[QRM NOTE]: Time elapsed since last: 0.001 seconds

[QRM NOTE]: Peak memory: 44076 bytes


=====================================================================================================

	[QI]: Quantifier Inference on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

=====================================================================================================


---------- quantifier_inference ----------


=== Prime Orbit 1 =====================
size : 6
num_suborbits: 4
1 (*) : ----11--
1     : ['message(node1,node0)', 'message(node1,node1)']
2     : --11----
2     : ['message(node0,node0)', 'message(node0,node1)']
7 (*) : --1-1---
7     : ['message(node0,node0)', 'message(node1,node0)']
8     : ---1-1--
8     : ['message(node0,node1)', 'message(node1,node1)']
9 (*) : ---11---
9     : ['message(node0,node1)', 'message(node1,node0)']
16 (*) : --1--1--
16     : ['message(node0,node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node1,node0)', 'message(node1,node1)']

sign_func_name2args: {'0$message': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$1], Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$1$0]}

sig2const: {'node$0$message$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node0)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$1$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$0; node$0$message$1$1, node$0$message$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$0; node$0$message$1$1 | node$0$message$0$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0; node$0$message$1$1 | node$0$message$0$1',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$1$0, node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node0)', 'message(node1,node1)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$1$0], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node1,node0)', 'message(node1,node1)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE3', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE3', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE2)', 'message(NODE1,NODE3)']


---------- QFormula: get_qclause ----------

qclause: forall NODE2,NODE3,NODE0,NODE1. ~message(NODE0,NODE2) | ~message(NODE1,NODE3) | (NODE2 = NODE3 & NODE0 = NODE1)


=== Prime Orbit 2 =====================
size : 8
num_suborbits: 4
3 (*) : -1--1---
3     : ['has_lock(node1)', 'message(node1,node0)']
4     : 1--1----
4     : ['has_lock(node0)', 'message(node0,node1)']
5 (*) : 1---1---
5     : ['has_lock(node0)', 'message(node1,node0)']
6     : -1-1----
6     : ['has_lock(node1)', 'message(node0,node1)']
12 (*) : 1-1-----
12     : ['has_lock(node0)', 'message(node0,node0)']
13     : -1---1--
13     : ['has_lock(node1)', 'message(node1,node1)']
14 (*) : -11-----
14     : ['has_lock(node1)', 'message(node0,node0)']
15     : 1----1--
15     : ['has_lock(node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node1)', 'message(node1,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))),)], '0$message': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0, node$0$message$0$0], Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node1,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))),)], '0$message': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0, node$0$message$1$0], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$1$0, node$0$message$0$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node0,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node1)', 'message(node0,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0], Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0, node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node1)', 'message(node1,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),), 'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0], 'node$0$message$0': [node$0$message$0$0], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0': node$0$has_lock$0$0, 'node$0$message$0': node$0$message$0$0, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE2)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE2,NODE0,NODE1. ~message(NODE1,NODE2) | ~has_lock(NODE0)


=== Prime Orbit 4 =====================
size : 1
num_suborbits: 1
11 (*) : 11------
11     : ['has_lock(node0)', 'has_lock(node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'has_lock(node1)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))),)]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$1]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

part_sig: ('node$0$has_lock$0$0 | node$0$has_lock$0$1',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'has_lock(node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),)}

sign_func_name2count:  {'0$has_lock': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: set()

exists_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: exists NODE0. ~has_lock(NODE0)


=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
17 (*) : 000000--
17     : ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']

sign_func_name2args: {'1$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))),)], '1$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$1$0, node$1$message$0$1, node$1$message$1$2], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$1$has_lock$0$1, node$1$message$1$1, node$1$message$0$2, node$1$message$0$3, node$1$message$1$3]}

sig2const: {'node$1$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$0$1': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$0$2': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$1$2': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$0$3': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$1$3': Const('node1', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2, node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2 | node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3}

part_sig: ('node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2 | node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3',)


---------- SigGenerator ----------

terms:  ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),), 'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'1$has_lock': 2, '1$message': 4}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2, node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2 | node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3}

	sort: node

	identical_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2, node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3]}

	identical_single_classes: {}

	identical_multi_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$0$1, node$1$message$1$0, node$1$message$1$2, node$1$has_lock$0$1, node$1$message$0$2, node$1$message$0$3, node$1$message$1$1, node$1$message$1$3]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: set()

exists_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'1$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]], '1$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['~message(NODE0,NODE1)', '~has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: exists NODE0,NODE1. message(NODE0,NODE1) | has_lock(NODE0)


===============================================================================================================

	[QI RESULT]: Quantified Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

===============================================================================================================


=== Prime Orbit 1 =====================
size : 6
num_suborbits: 4
1 (*) : ----11--
1     : ['message(node1,node0)', 'message(node1,node1)']
2     : --11----
2     : ['message(node0,node0)', 'message(node0,node1)']
7 (*) : --1-1---
7     : ['message(node0,node0)', 'message(node1,node0)']
8     : ---1-1--
8     : ['message(node0,node1)', 'message(node1,node1)']
9 (*) : ---11---
9     : ['message(node0,node1)', 'message(node1,node0)']
16 (*) : --1--1--
16     : ['message(node0,node0)', 'message(node1,node1)']
num_forall :   4
num_exists :   0
num_literals : 4
quantified form : forall NODE2,NODE3,NODE0,NODE1. ~message(NODE0,NODE2) | ~message(NODE1,NODE3) | (NODE2 = NODE3 & NODE0 = NODE1)
qcost : 8




=== Prime Orbit 2 =====================
size : 8
num_suborbits: 4
3 (*) : -1--1---
3     : ['has_lock(node1)', 'message(node1,node0)']
4     : 1--1----
4     : ['has_lock(node0)', 'message(node0,node1)']
5 (*) : 1---1---
5     : ['has_lock(node0)', 'message(node1,node0)']
6     : -1-1----
6     : ['has_lock(node1)', 'message(node0,node1)']
12 (*) : 1-1-----
12     : ['has_lock(node0)', 'message(node0,node0)']
13     : -1---1--
13     : ['has_lock(node1)', 'message(node1,node1)']
14 (*) : -11-----
14     : ['has_lock(node1)', 'message(node0,node0)']
15     : 1----1--
15     : ['has_lock(node0)', 'message(node1,node1)']
num_forall :   3
num_exists :   0
num_literals : 2
quantified form : forall NODE2,NODE0,NODE1. ~message(NODE1,NODE2) | ~has_lock(NODE0)
qcost : 5




=== Prime Orbit 4 =====================
size : 1
num_suborbits: 1
11 (*) : 11------
11     : ['has_lock(node0)', 'has_lock(node1)']
num_forall :   0
num_exists :   1
num_literals : 1
quantified form : exists NODE0. ~has_lock(NODE0)
qcost : 2




=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
17 (*) : 000000--
17     : ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']
num_forall :   0
num_exists :   2
num_literals : 2
quantified form : exists NODE0,NODE1. message(NODE0,NODE1) | has_lock(NODE0)
qcost : 4



[QRM NOTE]: Time elapsed since start: 1.858 seconds

[QRM NOTE]: Time elapsed since last: 1.829 seconds

[QRM NOTE]: Peak memory: 1901196 bytes


==============================================================================================

	[MIN]: Minimization on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

==============================================================================================


New level: 1
 pending : []
 solution : [1, 2, 4, 5]


Before reduction : 
 pending  : []
 solution : [1, 2, 4, 5]

Essensial at level 1 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

Covered at level 1 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 4, 5]


Solution : [1, 2, 4, 5] has cost 19.


Before backtrack at level 1
 pending : []
 solution : [1, 2, 4, 5]

After backtrack at level 1
 pending : []
 solution : [1, 2, 4, 5]


=============================================================================================================

	[MIN RESULT]: Minimized Invariants on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

=============================================================================================================

[MIN NOTE]: number of minimal solution found: 1

[MIN NOTE]: upper bound: 19

[MIN NOTE]: maximum branch and bound depth: 1

[MIN NOTE]: number of definitions: 0

[MIN NOTE]: number of equality relations: 0

[MIN NOTE]: Solution 0 : [1, 2, 4, 5]

[MIN NOTE]: solution length: 4

invariant [invar_1] forall NODE2,NODE3,NODE0,NODE1. ~message(NODE0,NODE2) | ~message(NODE1,NODE3) | (NODE2 = NODE3 & NODE0 = NODE1) # qcost: 8

invariant [invar_2] forall NODE2,NODE0,NODE1. ~message(NODE1,NODE2) | ~has_lock(NODE0) # qcost: 5

invariant [invar_4] exists NODE0. ~has_lock(NODE0) # qcost: 2

invariant [invar_5] exists NODE0,NODE1. message(NODE0,NODE1) | has_lock(NODE0) # qcost: 4

[MIN NOTE]: number of total invariants: 4

[MIN NOTE]: total qCost: 19




[QRM NOTE]: Time elapsed since start: 1.928 seconds

[QRM NOTE]: Time elapsed since last: 0.069 seconds

[QRM NOTE]: Peak memory: 1847036 bytes


**************************************************************************************************************

	[Reachability Convergence Check]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

**************************************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.node_2.0.ivy -s node=3 -f 2 -g -w -r -b -e -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


==============================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_2.0.ivy: node=3]

==============================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 15

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 6

[QRM NOTE]: Time elapsed since start: 0.132 seconds

[QRM NOTE]: Time elapsed since last: 0.132 seconds

[QRM NOTE]: Peak memory: 155089 bytes


===================================

	Forward reachability

===================================

building bdd for atoms

building bdd for initial action

building bdd for axioms

building bdd for actions

building bdd for action: send(fml:src,fml:dst)

building bdd for action: recv(fml:src,fml:dst)

building bdd for abstractions

start symbolic image computation

start extracting cubes

[FW NOTE]: number of reachable cubes: 36


========================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock: node=3]

========================================================================================================

sort: node=['node0', 'node1', 'node2']
predicate: has_lock('node',)
predicate: start_node=('node',)
predicate: message('node', 'node')
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'has_lock(node1)', 'has_lock(node2)', 'message(node0,node0)', 'message(node0,node1)', 'message(node0,node2)', 'message(node1,node0)', 'message(node1,node1)', 'message(node1,node2)', 'message(node2,node0)', 'message(node2,node1)', 'message(node2,node2)', '(start_node=node0)', '(start_node=node1)', '(start_node=node2)']

000000000001001
000000000001010
000000000001100
000000000010001
000000000010010
000000000010100
000000000100001
000000000100010
000000000100100
000000001000001
000000001000010
000000001000100
000000010000001
000000010000010
000000010000100
000000100000001
000000100000010
000000100000100
000001000000001
000001000000010
000001000000100
000010000000001
000010000000010
000010000000100
000100000000001
000100000000010
000100000000100
001000000000001
001000000000010
001000000000100
010000000000001
010000000000010
010000000000100
100000000000001
100000000000010
100000000000100

[QRM NOTE]: Time elapsed since start: 0.945 seconds

[QRM NOTE]: Time elapsed since last: 0.813 seconds

[QRM NOTE]: Peak memory: 1322148 bytes


==========================================================================================================================================

	[REACH_CHECK]: Reachability Convergence Check for Rmin on [ivybench/sym/ivy/simple-decentralized-lock.node_2.0.ivy: node=3]

==========================================================================================================================================

[REACH_CHECK RESULT]: FAIL

[QRM NOTE]: Time elapsed since start: 1.334 seconds

[QRM NOTE]: Time elapsed since last: 0.389 seconds

[QRM NOTE]: Peak memory: 593474 bytes

next size: node=3


***********************************************************************************************

	[Synthesize Rmin]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

***********************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.ivy -s node=3 -f 1 -g -w -r -b -e -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


---------- Initializing reachability from file ----------

OK


======================================

	Reduce Equivalent Atoms

======================================

[FW NOTE]: equivalent atoms

[FW NOTE]: complement atoms

[FW NOTE]: remove_atom_ids: set()

[QRM NOTE]: Time elapsed since start: 0.016 seconds

[QRM NOTE]: Time elapsed since last: 0.016 seconds

[QRM NOTE]: Peak memory: 10540 bytes


============================================================================================================

	[PRIME]: Prime Orbit Generatation on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

============================================================================================================


=======================================================================================================

	[PRIME RESULT]: Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

=======================================================================================================


=== Prime Orbit 0 =====================
size : 3
num_suborbits: 1
0 (*) : -------------11
0     : ['(start_node=node1)', '(start_node=node2)']
1     : ------------1-1
1     : ['(start_node=node0)', '(start_node=node2)']
2     : ------------11-
2     : ['(start_node=node0)', '(start_node=node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 1 =====================
size : 36
num_suborbits: 8
3 (*) : -------1---1---
3     : ['message(node1,node1)', 'message(node2,node2)']
4     : ---1-------1---
4     : ['message(node0,node0)', 'message(node2,node2)']
5     : ---1---1-------
5     : ['message(node0,node0)', 'message(node1,node1)']
15 (*) : ----1------1---
15     : ['message(node0,node1)', 'message(node2,node2)']
16     : -----1-1-------
16     : ['message(node0,node2)', 'message(node1,node1)']
17     : ------1----1---
17     : ['message(node1,node0)', 'message(node2,node2)']
18     : ---1----1------
18     : ['message(node0,node0)', 'message(node1,node2)']
19     : -------1-1-----
19     : ['message(node1,node1)', 'message(node2,node0)']
20     : ---1------1----
20     : ['message(node0,node0)', 'message(node2,node1)']
21 (*) : -----1-----1---
21     : ['message(node0,node2)', 'message(node2,node2)']
22     : ----1--1-------
22     : ['message(node0,node1)', 'message(node1,node1)']
23     : --------1--1---
23     : ['message(node1,node2)', 'message(node2,node2)']
24     : ---1--1--------
24     : ['message(node0,node0)', 'message(node1,node0)']
25     : -------1--1----
25     : ['message(node1,node1)', 'message(node2,node1)']
26     : ---1-----1-----
26     : ['message(node0,node0)', 'message(node2,node0)']
27 (*) : ---------1-1---
27     : ['message(node2,node0)', 'message(node2,node2)']
28     : ------11-------
28     : ['message(node1,node0)', 'message(node1,node1)']
29     : ----------11---
29     : ['message(node2,node1)', 'message(node2,node2)']
30     : ---11----------
30     : ['message(node0,node0)', 'message(node0,node1)']
31     : -------11------
31     : ['message(node1,node1)', 'message(node1,node2)']
32     : ---1-1---------
32     : ['message(node0,node0)', 'message(node0,node2)']
54 (*) : ----11---------
54     : ['message(node0,node1)', 'message(node0,node2)']
55     : ------1-1------
55     : ['message(node1,node0)', 'message(node1,node2)']
56     : ---------11----
56     : ['message(node2,node0)', 'message(node2,node1)']
57 (*) : -----11--------
57     : ['message(node0,node2)', 'message(node1,node0)']
58     : ----1----1-----
58     : ['message(node0,node1)', 'message(node2,node0)']
59     : ----1---1------
59     : ['message(node0,node1)', 'message(node1,node2)']
60     : ------1---1----
60     : ['message(node1,node0)', 'message(node2,node1)']
61     : -----1----1----
61     : ['message(node0,node2)', 'message(node2,node1)']
62     : --------11-----
62     : ['message(node1,node2)', 'message(node2,node0)']
63 (*) : ----1-1--------
63     : ['message(node0,node1)', 'message(node1,node0)']
64     : -----1---1-----
64     : ['message(node0,node2)', 'message(node2,node0)']
65     : --------1-1----
65     : ['message(node1,node2)', 'message(node2,node1)']
66 (*) : -----1--1------
66     : ['message(node0,node2)', 'message(node1,node2)']
67     : ----1-----1----
67     : ['message(node0,node1)', 'message(node2,node1)']
68     : ------1--1-----
68     : ['message(node1,node0)', 'message(node2,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 2 =====================
size : 27
num_suborbits: 5
6 (*) : 1----------1---
6     : ['has_lock(node0)', 'message(node2,node2)']
7     : 1------1-------
7     : ['has_lock(node0)', 'message(node1,node1)']
8     : -1---------1---
8     : ['has_lock(node1)', 'message(node2,node2)']
9     : -1-1-----------
9     : ['has_lock(node1)', 'message(node0,node0)']
10     : --1----1-------
10     : ['has_lock(node2)', 'message(node1,node1)']
11     : --11-----------
11     : ['has_lock(node2)', 'message(node0,node0)']
12 (*) : --1--------1---
12     : ['has_lock(node2)', 'message(node2,node2)']
13     : -1-----1-------
13     : ['has_lock(node1)', 'message(node1,node1)']
14     : 1--1-----------
14     : ['has_lock(node0)', 'message(node0,node0)']
36 (*) : 1---1----------
36     : ['has_lock(node0)', 'message(node0,node1)']
37     : 1----1---------
37     : ['has_lock(node0)', 'message(node0,node2)']
38     : -1----1--------
38     : ['has_lock(node1)', 'message(node1,node0)']
39     : -1------1------
39     : ['has_lock(node1)', 'message(node1,node2)']
40     : --1------1-----
40     : ['has_lock(node2)', 'message(node2,node0)']
41     : --1-------1----
41     : ['has_lock(node2)', 'message(node2,node1)']
42 (*) : -1--1----------
42     : ['has_lock(node1)', 'message(node0,node1)']
43     : --1--1---------
43     : ['has_lock(node2)', 'message(node0,node2)']
44     : 1-----1--------
44     : ['has_lock(node0)', 'message(node1,node0)']
45     : --1-----1------
45     : ['has_lock(node2)', 'message(node1,node2)']
46     : 1--------1-----
46     : ['has_lock(node0)', 'message(node2,node0)']
47     : -1--------1----
47     : ['has_lock(node1)', 'message(node2,node1)']
48 (*) : --1-1----------
48     : ['has_lock(node2)', 'message(node0,node1)']
49     : -1---1---------
49     : ['has_lock(node1)', 'message(node0,node2)']
50     : --1---1--------
50     : ['has_lock(node2)', 'message(node1,node0)']
51     : 1-------1------
51     : ['has_lock(node0)', 'message(node1,node2)']
52     : -1-------1-----
52     : ['has_lock(node1)', 'message(node2,node0)']
53     : 1---------1----
53     : ['has_lock(node0)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 3 =====================
size : 3
num_suborbits: 1
33 (*) : 11-------------
33     : ['has_lock(node0)', 'has_lock(node1)']
34     : 1-1------------
34     : ['has_lock(node0)', 'has_lock(node2)']
35     : -11------------
35     : ['has_lock(node1)', 'has_lock(node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 4 =====================
size : 1
num_suborbits: 1
69 (*) : ------------000
69     : ['~(start_node=node0)', '~(start_node=node1)', '~(start_node=node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
70 (*) : 000000000000---
70     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0



[PRIME NOTE]: number of orbits after merging: 6

[PRIME NOTE]: number of orbits before merging: 17

[PRIME NOTE]: number of primes: 71

[QRM NOTE]: Time elapsed since start: 0.038 seconds

[QRM NOTE]: Time elapsed since last: 0.022 seconds

[QRM NOTE]: Peak memory: 1177718 bytes


=================================================================================================

	[RED]: PRIME REDUCTION on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

=================================================================================================

definition primes: {0, 4}


New level: 0
 pending : [1, 2, 3, 5]
 solution : []


Before reduction : 
 pending  : [1, 2, 3, 5]
 solution : []

Essensial at level 0 : {1, 2, 3, 5}

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 5]


Before reduction : 
 pending  : []
 solution : [1, 2, 3, 5]

Essensial at level 0 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 5]

[QRM NOTE]: Time elapsed since start: 0.040 seconds

[QRM NOTE]: Time elapsed since last: 0.002 seconds

[QRM NOTE]: Peak memory: 131531 bytes


=====================================================================================================

	[QI]: Quantifier Inference on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

=====================================================================================================


---------- quantifier_inference ----------


=== Prime Orbit 1 =====================
size : 36
num_suborbits: 8
3 (*) : -------1---1---
3     : ['message(node1,node1)', 'message(node2,node2)']
4     : ---1-------1---
4     : ['message(node0,node0)', 'message(node2,node2)']
5     : ---1---1-------
5     : ['message(node0,node0)', 'message(node1,node1)']
15 (*) : ----1------1---
15     : ['message(node0,node1)', 'message(node2,node2)']
16     : -----1-1-------
16     : ['message(node0,node2)', 'message(node1,node1)']
17     : ------1----1---
17     : ['message(node1,node0)', 'message(node2,node2)']
18     : ---1----1------
18     : ['message(node0,node0)', 'message(node1,node2)']
19     : -------1-1-----
19     : ['message(node1,node1)', 'message(node2,node0)']
20     : ---1------1----
20     : ['message(node0,node0)', 'message(node2,node1)']
21 (*) : -----1-----1---
21     : ['message(node0,node2)', 'message(node2,node2)']
22     : ----1--1-------
22     : ['message(node0,node1)', 'message(node1,node1)']
23     : --------1--1---
23     : ['message(node1,node2)', 'message(node2,node2)']
24     : ---1--1--------
24     : ['message(node0,node0)', 'message(node1,node0)']
25     : -------1--1----
25     : ['message(node1,node1)', 'message(node2,node1)']
26     : ---1-----1-----
26     : ['message(node0,node0)', 'message(node2,node0)']
27 (*) : ---------1-1---
27     : ['message(node2,node0)', 'message(node2,node2)']
28     : ------11-------
28     : ['message(node1,node0)', 'message(node1,node1)']
29     : ----------11---
29     : ['message(node2,node1)', 'message(node2,node2)']
30     : ---11----------
30     : ['message(node0,node0)', 'message(node0,node1)']
31     : -------11------
31     : ['message(node1,node1)', 'message(node1,node2)']
32     : ---1-1---------
32     : ['message(node0,node0)', 'message(node0,node2)']
54 (*) : ----11---------
54     : ['message(node0,node1)', 'message(node0,node2)']
55     : ------1-1------
55     : ['message(node1,node0)', 'message(node1,node2)']
56     : ---------11----
56     : ['message(node2,node0)', 'message(node2,node1)']
57 (*) : -----11--------
57     : ['message(node0,node2)', 'message(node1,node0)']
58     : ----1----1-----
58     : ['message(node0,node1)', 'message(node2,node0)']
59     : ----1---1------
59     : ['message(node0,node1)', 'message(node1,node2)']
60     : ------1---1----
60     : ['message(node1,node0)', 'message(node2,node1)']
61     : -----1----1----
61     : ['message(node0,node2)', 'message(node2,node1)']
62     : --------11-----
62     : ['message(node1,node2)', 'message(node2,node0)']
63 (*) : ----1-1--------
63     : ['message(node0,node1)', 'message(node1,node0)']
64     : -----1---1-----
64     : ['message(node0,node2)', 'message(node2,node0)']
65     : --------1-1----
65     : ['message(node1,node2)', 'message(node2,node1)']
66 (*) : -----1--1------
66     : ['message(node0,node2)', 'message(node1,node2)']
67     : ----1-----1----
67     : ['message(node0,node1)', 'message(node2,node1)']
68     : ------1--1-----
68     : ['message(node1,node0)', 'message(node2,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node1,node1)', 'message(node2,node2)']

sign_func_name2args: {'0$message': [(Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node2,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

part_sig: ('node$0$message$0$0 | node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node2)', 'message(node2,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0, node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1; node$0$message$1$0; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1; node$0$message$1$0; node$0$message$1$1}

part_sig: ('node$0$message$0$0 | node$0$message$0$1; node$0$message$1$0; node$0$message$1$1',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node2,node0)', 'message(node2,node2)']

sign_func_name2args: {'0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$1], Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0]}

sig2const: {'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node0,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$0$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node2)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$1$1], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1 | node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1 | node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0, node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node2)', 'message(node1,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0; node$0$message$1$1}

part_sig: ('node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0; node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node1,node1)', 'message(node2,node2)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE3', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE3', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE3)', 'message(NODE0,NODE2)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE2,NODE0,NODE3. ~message(NODE1,NODE3) | ~message(NODE0,NODE2) | (NODE0 = NODE1 & NODE2 = NODE3)


=== Prime Orbit 2 =====================
size : 27
num_suborbits: 5
6 (*) : 1----------1---
6     : ['has_lock(node0)', 'message(node2,node2)']
7     : 1------1-------
7     : ['has_lock(node0)', 'message(node1,node1)']
8     : -1---------1---
8     : ['has_lock(node1)', 'message(node2,node2)']
9     : -1-1-----------
9     : ['has_lock(node1)', 'message(node0,node0)']
10     : --1----1-------
10     : ['has_lock(node2)', 'message(node1,node1)']
11     : --11-----------
11     : ['has_lock(node2)', 'message(node0,node0)']
12 (*) : --1--------1---
12     : ['has_lock(node2)', 'message(node2,node2)']
13     : -1-----1-------
13     : ['has_lock(node1)', 'message(node1,node1)']
14     : 1--1-----------
14     : ['has_lock(node0)', 'message(node0,node0)']
36 (*) : 1---1----------
36     : ['has_lock(node0)', 'message(node0,node1)']
37     : 1----1---------
37     : ['has_lock(node0)', 'message(node0,node2)']
38     : -1----1--------
38     : ['has_lock(node1)', 'message(node1,node0)']
39     : -1------1------
39     : ['has_lock(node1)', 'message(node1,node2)']
40     : --1------1-----
40     : ['has_lock(node2)', 'message(node2,node0)']
41     : --1-------1----
41     : ['has_lock(node2)', 'message(node2,node1)']
42 (*) : -1--1----------
42     : ['has_lock(node1)', 'message(node0,node1)']
43     : --1--1---------
43     : ['has_lock(node2)', 'message(node0,node2)']
44     : 1-----1--------
44     : ['has_lock(node0)', 'message(node1,node0)']
45     : --1-----1------
45     : ['has_lock(node2)', 'message(node1,node2)']
46     : 1--------1-----
46     : ['has_lock(node0)', 'message(node2,node0)']
47     : -1--------1----
47     : ['has_lock(node1)', 'message(node2,node1)']
48 (*) : --1-1----------
48     : ['has_lock(node2)', 'message(node0,node1)']
49     : -1---1---------
49     : ['has_lock(node1)', 'message(node0,node2)']
50     : --1---1--------
50     : ['has_lock(node2)', 'message(node1,node0)']
51     : 1-------1------
51     : ['has_lock(node0)', 'message(node1,node2)']
52     : -1-------1-----
52     : ['has_lock(node1)', 'message(node2,node0)']
53     : 1---------1----
53     : ['has_lock(node0)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node2,node2)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node2)', 'message(node2,node2)']

sign_func_name2args: {'0$has_lock': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node0,node1)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0, node$0$message$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node1)', 'message(node0,node1)']

sign_func_name2args: {'0$has_lock': [(Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0, node$0$message$1$0], Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0]}

sig2const: {'node$0$has_lock$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$1$0, node$0$message$0$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0',)


---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node2)', 'message(node0,node1)']

sign_func_name2args: {'0$has_lock': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0], Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node2,node2)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0], 'node$0$message$0': [node$0$message$0$0], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0': node$0$has_lock$0$0, 'node$0$message$0': node$0$message$0$0, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'message(NODE1,NODE2)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE2,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE2)


=== Prime Orbit 3 =====================
size : 3
num_suborbits: 1
33 (*) : 11-------------
33     : ['has_lock(node0)', 'has_lock(node1)']
34     : 1-1------------
34     : ['has_lock(node0)', 'has_lock(node2)']
35     : -11------------
35     : ['has_lock(node1)', 'has_lock(node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'has_lock(node1)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$1]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

part_sig: ('node$0$has_lock$0$0 | node$0$has_lock$0$1',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'has_lock(node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),)}

sign_func_name2count:  {'0$has_lock': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'has_lock(NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~has_lock(NODE0) | ~has_lock(NODE1) | NODE0 = NODE1


=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
70 (*) : 000000000000---
70     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']

sign_func_name2args: {'1$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))),), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '1$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$1$0, node$1$message$0$1, node$1$message$0$2, node$1$message$1$3, node$1$message$1$6], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$1$has_lock$0$1, node$1$message$1$1, node$1$message$0$3, node$1$message$0$4, node$1$message$1$4, node$1$message$0$5, node$1$message$1$7], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$1$has_lock$0$2, node$1$message$1$2, node$1$message$1$5, node$1$message$0$6, node$1$message$0$7, node$1$message$0$8, node$1$message$1$8]}

sig2const: {'node$1$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$has_lock$0$2': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$2': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$2': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$3': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$3': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$4': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$4': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$5': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$5': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$6': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$6': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$7': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$7': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$8': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$8': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6, node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7, node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6 | node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7 | node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8}

part_sig: ('node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6 | node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7 | node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8',)


---------- SigGenerator ----------

terms:  ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'1$has_lock': 3, '1$message': 9}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6, node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7, node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6 | node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7 | node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8}

	sort: node

	identical_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6, node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7, node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8]}

	identical_single_classes: {}

	identical_multi_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$0$1, node$1$message$0$2, node$1$message$1$0, node$1$message$1$3, node$1$message$1$6, node$1$has_lock$0$1, node$1$message$0$3, node$1$message$0$4, node$1$message$0$5, node$1$message$1$1, node$1$message$1$4, node$1$message$1$7, node$1$has_lock$0$2, node$1$message$0$6, node$1$message$0$7, node$1$message$0$8, node$1$message$1$2, node$1$message$1$5, node$1$message$1$8]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: set()

exists_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'1$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]], '1$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['~has_lock(NODE0)', '~message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: exists NODE1,NODE0. has_lock(NODE0) | message(NODE0,NODE1)


===============================================================================================================

	[QI RESULT]: Quantified Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

===============================================================================================================


=== Prime Orbit 1 =====================
size : 36
num_suborbits: 8
3 (*) : -------1---1---
3     : ['message(node1,node1)', 'message(node2,node2)']
4     : ---1-------1---
4     : ['message(node0,node0)', 'message(node2,node2)']
5     : ---1---1-------
5     : ['message(node0,node0)', 'message(node1,node1)']
15 (*) : ----1------1---
15     : ['message(node0,node1)', 'message(node2,node2)']
16     : -----1-1-------
16     : ['message(node0,node2)', 'message(node1,node1)']
17     : ------1----1---
17     : ['message(node1,node0)', 'message(node2,node2)']
18     : ---1----1------
18     : ['message(node0,node0)', 'message(node1,node2)']
19     : -------1-1-----
19     : ['message(node1,node1)', 'message(node2,node0)']
20     : ---1------1----
20     : ['message(node0,node0)', 'message(node2,node1)']
21 (*) : -----1-----1---
21     : ['message(node0,node2)', 'message(node2,node2)']
22     : ----1--1-------
22     : ['message(node0,node1)', 'message(node1,node1)']
23     : --------1--1---
23     : ['message(node1,node2)', 'message(node2,node2)']
24     : ---1--1--------
24     : ['message(node0,node0)', 'message(node1,node0)']
25     : -------1--1----
25     : ['message(node1,node1)', 'message(node2,node1)']
26     : ---1-----1-----
26     : ['message(node0,node0)', 'message(node2,node0)']
27 (*) : ---------1-1---
27     : ['message(node2,node0)', 'message(node2,node2)']
28     : ------11-------
28     : ['message(node1,node0)', 'message(node1,node1)']
29     : ----------11---
29     : ['message(node2,node1)', 'message(node2,node2)']
30     : ---11----------
30     : ['message(node0,node0)', 'message(node0,node1)']
31     : -------11------
31     : ['message(node1,node1)', 'message(node1,node2)']
32     : ---1-1---------
32     : ['message(node0,node0)', 'message(node0,node2)']
54 (*) : ----11---------
54     : ['message(node0,node1)', 'message(node0,node2)']
55     : ------1-1------
55     : ['message(node1,node0)', 'message(node1,node2)']
56     : ---------11----
56     : ['message(node2,node0)', 'message(node2,node1)']
57 (*) : -----11--------
57     : ['message(node0,node2)', 'message(node1,node0)']
58     : ----1----1-----
58     : ['message(node0,node1)', 'message(node2,node0)']
59     : ----1---1------
59     : ['message(node0,node1)', 'message(node1,node2)']
60     : ------1---1----
60     : ['message(node1,node0)', 'message(node2,node1)']
61     : -----1----1----
61     : ['message(node0,node2)', 'message(node2,node1)']
62     : --------11-----
62     : ['message(node1,node2)', 'message(node2,node0)']
63 (*) : ----1-1--------
63     : ['message(node0,node1)', 'message(node1,node0)']
64     : -----1---1-----
64     : ['message(node0,node2)', 'message(node2,node0)']
65     : --------1-1----
65     : ['message(node1,node2)', 'message(node2,node1)']
66 (*) : -----1--1------
66     : ['message(node0,node2)', 'message(node1,node2)']
67     : ----1-----1----
67     : ['message(node0,node1)', 'message(node2,node1)']
68     : ------1--1-----
68     : ['message(node1,node0)', 'message(node2,node0)']
num_forall :   4
num_exists :   0
num_literals : 4
quantified form : forall NODE1,NODE2,NODE0,NODE3. ~message(NODE1,NODE3) | ~message(NODE0,NODE2) | (NODE0 = NODE1 & NODE2 = NODE3)
qcost : 8




=== Prime Orbit 2 =====================
size : 27
num_suborbits: 5
6 (*) : 1----------1---
6     : ['has_lock(node0)', 'message(node2,node2)']
7     : 1------1-------
7     : ['has_lock(node0)', 'message(node1,node1)']
8     : -1---------1---
8     : ['has_lock(node1)', 'message(node2,node2)']
9     : -1-1-----------
9     : ['has_lock(node1)', 'message(node0,node0)']
10     : --1----1-------
10     : ['has_lock(node2)', 'message(node1,node1)']
11     : --11-----------
11     : ['has_lock(node2)', 'message(node0,node0)']
12 (*) : --1--------1---
12     : ['has_lock(node2)', 'message(node2,node2)']
13     : -1-----1-------
13     : ['has_lock(node1)', 'message(node1,node1)']
14     : 1--1-----------
14     : ['has_lock(node0)', 'message(node0,node0)']
36 (*) : 1---1----------
36     : ['has_lock(node0)', 'message(node0,node1)']
37     : 1----1---------
37     : ['has_lock(node0)', 'message(node0,node2)']
38     : -1----1--------
38     : ['has_lock(node1)', 'message(node1,node0)']
39     : -1------1------
39     : ['has_lock(node1)', 'message(node1,node2)']
40     : --1------1-----
40     : ['has_lock(node2)', 'message(node2,node0)']
41     : --1-------1----
41     : ['has_lock(node2)', 'message(node2,node1)']
42 (*) : -1--1----------
42     : ['has_lock(node1)', 'message(node0,node1)']
43     : --1--1---------
43     : ['has_lock(node2)', 'message(node0,node2)']
44     : 1-----1--------
44     : ['has_lock(node0)', 'message(node1,node0)']
45     : --1-----1------
45     : ['has_lock(node2)', 'message(node1,node2)']
46     : 1--------1-----
46     : ['has_lock(node0)', 'message(node2,node0)']
47     : -1--------1----
47     : ['has_lock(node1)', 'message(node2,node1)']
48 (*) : --1-1----------
48     : ['has_lock(node2)', 'message(node0,node1)']
49     : -1---1---------
49     : ['has_lock(node1)', 'message(node0,node2)']
50     : --1---1--------
50     : ['has_lock(node2)', 'message(node1,node0)']
51     : 1-------1------
51     : ['has_lock(node0)', 'message(node1,node2)']
52     : -1-------1-----
52     : ['has_lock(node1)', 'message(node2,node0)']
53     : 1---------1----
53     : ['has_lock(node0)', 'message(node2,node1)']
num_forall :   3
num_exists :   0
num_literals : 2
quantified form : forall NODE1,NODE2,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE2)
qcost : 5




=== Prime Orbit 3 =====================
size : 3
num_suborbits: 1
33 (*) : 11-------------
33     : ['has_lock(node0)', 'has_lock(node1)']
34     : 1-1------------
34     : ['has_lock(node0)', 'has_lock(node2)']
35     : -11------------
35     : ['has_lock(node1)', 'has_lock(node2)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~has_lock(NODE0) | ~has_lock(NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
70 (*) : 000000000000---
70     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']
num_forall :   0
num_exists :   2
num_literals : 2
quantified form : exists NODE1,NODE0. has_lock(NODE0) | message(NODE0,NODE1)
qcost : 4



[QRM NOTE]: Time elapsed since start: 1.929 seconds

[QRM NOTE]: Time elapsed since last: 1.889 seconds

[QRM NOTE]: Peak memory: 2034382 bytes


==============================================================================================

	[MIN]: Minimization on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

==============================================================================================


New level: 1
 pending : []
 solution : [1, 2, 3, 5]


Before reduction : 
 pending  : []
 solution : [1, 2, 3, 5]

Essensial at level 1 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1)]

Covered at level 1 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 5]


Solution : [1, 2, 3, 5] has cost 22.


Before backtrack at level 1
 pending : []
 solution : [1, 2, 3, 5]

After backtrack at level 1
 pending : []
 solution : [1, 2, 3, 5]


=============================================================================================================

	[MIN RESULT]: Minimized Invariants on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

=============================================================================================================

[MIN NOTE]: number of minimal solution found: 1

[MIN NOTE]: upper bound: 22

[MIN NOTE]: maximum branch and bound depth: 1

[MIN NOTE]: number of definitions: 0

[MIN NOTE]: number of equality relations: 0

[MIN NOTE]: Solution 0 : [1, 2, 3, 5]

[MIN NOTE]: solution length: 4

invariant [invar_1] forall NODE1,NODE2,NODE0,NODE3. ~message(NODE1,NODE3) | ~message(NODE0,NODE2) | (NODE0 = NODE1 & NODE2 = NODE3) # qcost: 8

invariant [invar_2] forall NODE1,NODE2,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE2) # qcost: 5

invariant [invar_3] forall NODE1,NODE0. ~has_lock(NODE0) | ~has_lock(NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_5] exists NODE1,NODE0. has_lock(NODE0) | message(NODE0,NODE1) # qcost: 4

[MIN NOTE]: number of total invariants: 4

[MIN NOTE]: total qCost: 22




[QRM NOTE]: Time elapsed since start: 2.002 seconds

[QRM NOTE]: Time elapsed since last: 0.073 seconds

[QRM NOTE]: Peak memory: 1919519 bytes


**************************************************************************************************************

	[Reachability Convergence Check]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

**************************************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy -s node=4 -f 2 -g -w -r -b -e -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


==============================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: node=4]

==============================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 24

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 24

[QRM NOTE]: Time elapsed since start: 0.265 seconds

[QRM NOTE]: Time elapsed since last: 0.265 seconds

[QRM NOTE]: Peak memory: 479317 bytes


===================================

	Forward reachability

===================================

building bdd for atoms

building bdd for initial action

building bdd for axioms

building bdd for actions

building bdd for action: send(fml:src,fml:dst)

building bdd for action: recv(fml:src,fml:dst)

building bdd for abstractions

start symbolic image computation

start extracting cubes

[FW NOTE]: number of reachable cubes: 80


========================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock: node=4]

========================================================================================================

sort: node=['node0', 'node1', 'node2', 'node3']
predicate: has_lock('node',)
predicate: message('node', 'node')
predicate: start_node=('node',)
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'has_lock(node1)', 'has_lock(node2)', 'has_lock(node3)', 'message(node0,node0)', 'message(node0,node1)', 'message(node0,node2)', 'message(node0,node3)', 'message(node1,node0)', 'message(node1,node1)', 'message(node1,node2)', 'message(node1,node3)', 'message(node2,node0)', 'message(node2,node1)', 'message(node2,node2)', 'message(node2,node3)', 'message(node3,node0)', 'message(node3,node1)', 'message(node3,node2)', 'message(node3,node3)', '(start_node=node0)', '(start_node=node1)', '(start_node=node2)', '(start_node=node3)']

000000000000000000010001
000000000000000000010010
000000000000000000010100
000000000000000000011000
000000000000000000100001
000000000000000000100010
000000000000000000100100
000000000000000000101000
000000000000000001000001
000000000000000001000010
000000000000000001000100
000000000000000001001000
000000000000000010000001
000000000000000010000010
000000000000000010000100
000000000000000010001000
000000000000000100000001
000000000000000100000010
000000000000000100000100
000000000000000100001000
000000000000001000000001
000000000000001000000010
000000000000001000000100
000000000000001000001000
000000000000010000000001
000000000000010000000010
000000000000010000000100
000000000000010000001000
000000000000100000000001
000000000000100000000010
000000000000100000000100
000000000000100000001000
000000000001000000000001
000000000001000000000010
000000000001000000000100
000000000001000000001000
000000000010000000000001
000000000010000000000010
000000000010000000000100
000000000010000000001000
000000000100000000000001
000000000100000000000010
000000000100000000000100
000000000100000000001000
000000001000000000000001
000000001000000000000010
000000001000000000000100
000000001000000000001000
000000010000000000000001
000000010000000000000010
000000010000000000000100
000000010000000000001000
000000100000000000000001
000000100000000000000010
000000100000000000000100
000000100000000000001000
000001000000000000000001
000001000000000000000010
000001000000000000000100
000001000000000000001000
000010000000000000000001
000010000000000000000010
000010000000000000000100
000010000000000000001000
000100000000000000000001
000100000000000000000010
000100000000000000000100
000100000000000000001000
001000000000000000000001
001000000000000000000010
001000000000000000000100
001000000000000000001000
010000000000000000000001
010000000000000000000010
010000000000000000000100
010000000000000000001000
100000000000000000000001
100000000000000000000010
100000000000000000000100
100000000000000000001000

[QRM NOTE]: Time elapsed since start: 2.613 seconds

[QRM NOTE]: Time elapsed since last: 2.348 seconds

[QRM NOTE]: Peak memory: 1796839 bytes


==========================================================================================================================================

	[REACH_CHECK]: Reachability Convergence Check for Rmin on [ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: node=4]

==========================================================================================================================================

[REACH_CHECK RESULT]: PASS

[QRM NOTE]: Time elapsed since start: 3.940 seconds

[QRM NOTE]: Time elapsed since last: 1.327 seconds

[QRM NOTE]: Peak memory: 1795237 bytes


*********************************************************************

	[IVY_CHECK]: Ivy Check for Reachability Invariant

*********************************************************************


==================================================================================================

	[IVY_CHECK]: Ivy check on [ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy]

==================================================================================================

ivy_check complete=fo ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy


Isolate this:

    The inductive invariant consists of the following conjectures:
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 39: invar_1
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 40: invar_2
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 41: invar_3
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 42: invar_5

    The following action implementations are present:
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 23: implementation of recv
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 17: implementation of send

    The following initializers are present:
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 12: init[after1]

    Initialization must establish the invariant
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 39: invar_1 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 40: invar_2 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 41: invar_3 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 42: invar_5 ... PASS

    The following set of external actions must preserve the invariant:
        (internal) ext:recv
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 39: invar_1 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 40: invar_2 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 41: invar_3 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 42: invar_5 ... PASS
        (internal) ext:send
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 39: invar_1 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 40: invar_2 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 41: invar_3 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 42: invar_5 ... PASS

    The following program assertions are treated as assumptions:
        in action send when called from the environment:
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 18: assumption
        in action recv when called from the environment:
            ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: line 24: assumption

OK
[IVY_CHECK RESULT]: PASS


**********************************************************************************

	[QRM]: ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy

**********************************************************************************

[RMIN NUM]: 1

[RMIN RESULT]: ['ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy']

[CUTOFF]: node=3

[QRM RESULT]: PASS

[QRM NOTE]: Time elapsed since start: 28.584 seconds

[QRM NOTE]: Time elapsed since last: 28.584 seconds

