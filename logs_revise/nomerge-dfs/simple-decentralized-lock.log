
*************************************************************************

	[QRM]: ivybench/sym/ivy/simple-decentralized-lock.ivy

*************************************************************************


***********************************************************************************************

	[Synthesize Rmin]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

***********************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.ivy -s node=1 -f 1 -g -w -r -m -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


=====================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=====================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 3

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 1

[FW NOTE]: number of branching actions: 2

ivy_to_cpp target=qrm simple-decentralized-lock.node_1.finite.ivy

[IVY_TO_CPP RESULT]: OK

swig -c++ -python -o simple-decentralized-lock.node_1.finite_wrap.cpp ivy_exec.i

[SWIG RESULT]: OK

g++ -std=c++11 -fpic -pthread -O3 simple-decentralized-lock.node_1.finite.cpp simple-decentralized-lock.node_1.finite_wrap.cpp -I/home/yunrong/.pyenv/versions/3.12.0/include/python3.12 -c

[G++ RESULT]: OK

g++ -shared simple-decentralized-lock.node_1.finite.o simple-decentralized-lock.node_1.finite_wrap.o -o _ivy_exec.so -lm -lstdc++

[LINK RESULT]: OK

[QRM NOTE]: Time elapsed since start: 6.231 seconds

[QRM NOTE]: Time elapsed since last: 6.231 seconds

[QRM NOTE]: Peak memory: 1171861 bytes


===================================

	Forward reachability

===================================

[FW NOTE]: dfs max depth: 1

[FW NOTE]: number of total reachable states:        2

[FW NOTE]: number of dfs representative states:     2

[FW NOTE]: number of dfs non-representative states: 0


============================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

============================================================================================================

sort: node=['node0']
predicate: message('node', 'node')
predicate: start_node=('node',)
predicate: has_lock('node',)
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'message(node0,node0)', '(start_node=node0)']
representative states : 5, 3


=== State Orbit 0 =====================
size : 1
repr state: 101
lex min decimal: 5
states:
101




=== State Orbit 1 =====================
size : 1
repr state: 011
lex min decimal: 3
states:
011



[QRM NOTE]: Time elapsed since start: 6.308 seconds

[QRM NOTE]: Time elapsed since last: 0.077 seconds

[QRM NOTE]: Peak memory: 1196400 bytes


======================================

	Reduce Equivalent Atoms

======================================

[FW NOTE]: equivalent atoms

[FW NOTE]: complement atoms

[FW NOTE]: remove_atom_ids: set()

[QRM NOTE]: Time elapsed since start: 6.311 seconds

[QRM NOTE]: Time elapsed since last: 0.003 seconds

[QRM NOTE]: Peak memory: 147284 bytes


============================================================================================================

	[PRIME]: Prime Orbit Generatation on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

============================================================================================================


=======================================================================================================

	[PRIME RESULT]: Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=======================================================================================================


=== Prime Orbit 0 =====================
size : 1
num_suborbits: 1
0 (*) : --0
0     : ['~(start_node=node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 1 =====================
size : 1
num_suborbits: 1
1 (*) : 00-
1     : ['~has_lock(node0)', '~message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 2 =====================
size : 1
num_suborbits: 1
2 (*) : 11-
2     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0



[PRIME NOTE]: number of orbits after merging: 3

[PRIME NOTE]: number of orbits before merging: 3

[PRIME NOTE]: number of primes: 3

[QRM NOTE]: Time elapsed since start: 6.320 seconds

[QRM NOTE]: Time elapsed since last: 0.009 seconds

[QRM NOTE]: Peak memory: 1203794 bytes


=================================================================================================

	[RED]: PRIME REDUCTION on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=================================================================================================

definition primes: {0}


New level: 0
 pending : [1, 2]
 solution : []


Before reduction : 
 pending  : [1, 2]
 solution : []

Essensial at level 0 : {1, 2}

Before removed
 coverage : [(0, -1), (1, -1), (2, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2]


Before reduction : 
 pending  : []
 solution : [1, 2]

Essensial at level 0 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2]

[QRM NOTE]: Time elapsed since start: 6.321 seconds

[QRM NOTE]: Time elapsed since last: 0.001 seconds

[QRM NOTE]: Peak memory: 155809 bytes


=====================================================================================================

	[QI]: Quantifier Inference on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=====================================================================================================


---------- quantifier_inference ----------


=== Prime Orbit 1 =====================
size : 1
num_suborbits: 1
1 (*) : 00-
1     : ['~has_lock(node0)', '~message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['~has_lock(node0)', '~message(node0,node0)']

sign_func_name2args: {'1$has_lock': [(Const('node0', EnumeratedSort('node', ('node0',))),)], '1$message': [(Const('node0', EnumeratedSort('node', ('node0',))), Const('node0', EnumeratedSort('node', ('node0',))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0',))): [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$1$0]}

sig2const: {'node$1$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0',))), 'node$1$message$0$0': Const('node0', EnumeratedSort('node', ('node0',))), 'node$1$message$1$0': Const('node0', EnumeratedSort('node', ('node0',)))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0',)): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0',)): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0}

part_sig: ('node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0',)


---------- SigGenerator ----------

terms:  ['~has_lock(node0)', '~message(node0,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0',)), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0',)), EnumeratedSort('node', ('node0',)), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0',)),), 'message': (EnumeratedSort('node', ('node0',)), EnumeratedSort('node', ('node0',)))}

sign_func_name2count:  {'1$has_lock': 1, '1$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0',)): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0',)): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0}

	sort: node

	identical_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$1': [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0]}

	identical_single_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$1': node$1$has_lock$0$0; node$1$message$0$0; node$1$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0',)))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'1$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0',)))]], '1$message': [[Var('NODE0', EnumeratedSort('node', ('node0',))), Var('NODE0', EnumeratedSort('node', ('node0',)))]]}


---------- QFormula: _set_qterms ----------

qterms: ['~message(NODE0,NODE0)', '~has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0. message(NODE0,NODE0) | has_lock(NODE0)


=== Prime Orbit 2 =====================
size : 1
num_suborbits: 1
2 (*) : 11-
2     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node0,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0',))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0',))), Const('node0', EnumeratedSort('node', ('node0',))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0',))): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0',))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0',))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0',)))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0',)): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0',)): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node0,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0',)), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0',)), EnumeratedSort('node', ('node0',)), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0',)),), 'message': (EnumeratedSort('node', ('node0',)), EnumeratedSort('node', ('node0',)))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0',)): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0',)): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0',)))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0',)))]], '0$message': [[Var('NODE0', EnumeratedSort('node', ('node0',))), Var('NODE0', EnumeratedSort('node', ('node0',)))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0)


===============================================================================================================

	[QI RESULT]: Quantified Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

===============================================================================================================


=== Prime Orbit 1 =====================
size : 1
num_suborbits: 1
1 (*) : 00-
1     : ['~has_lock(node0)', '~message(node0,node0)']
num_forall :   1
num_exists :   0
num_literals : 2
quantified form : forall NODE0. message(NODE0,NODE0) | has_lock(NODE0)
qcost : 3




=== Prime Orbit 2 =====================
size : 1
num_suborbits: 1
2 (*) : 11-
2     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   1
num_exists :   0
num_literals : 2
quantified form : forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0)
qcost : 3



[QRM NOTE]: Time elapsed since start: 6.375 seconds

[QRM NOTE]: Time elapsed since last: 0.054 seconds

[QRM NOTE]: Peak memory: 1878544 bytes


==============================================================================================

	[MIN]: Minimization on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

==============================================================================================


New level: 1
 pending : []
 solution : [1, 2]


Before reduction : 
 pending  : []
 solution : [1, 2]

Essensial at level 1 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1)]

Covered at level 1 : set()

After reduction : 
 pending  : []
 solution : [1, 2]


Solution : [1, 2] has cost 6.


Before backtrack at level 1
 pending : []
 solution : [1, 2]

After backtrack at level 1
 pending : []
 solution : [1, 2]


=============================================================================================================

	[MIN RESULT]: Minimized Invariants on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

=============================================================================================================

[MIN NOTE]: number of minimal solution found: 1

[MIN NOTE]: upper bound: 6

[MIN NOTE]: maximum branch and bound depth: 1

[MIN NOTE]: number of definitions: 0

[MIN NOTE]: number of equality relations: 0

[MIN NOTE]: Solution 0 : [1, 2]

[MIN NOTE]: solution length: 2

invariant [invar_1] forall NODE0. message(NODE0,NODE0) | has_lock(NODE0) # qcost: 3

invariant [invar_2] forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0) # qcost: 3

[MIN NOTE]: number of total invariants: 2

[MIN NOTE]: total qCost: 6




[QRM NOTE]: Time elapsed since start: 6.409 seconds

[QRM NOTE]: Time elapsed since last: 0.033 seconds

[QRM NOTE]: Peak memory: 1868335 bytes


**************************************************************************************************************

	[Reachability Convergence Check]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=1]

**************************************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.node_1.0.ivy -s node=2 -f 2 -g -w -r -m -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


==============================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_1.0.ivy: node=2]

==============================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 8

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 2

[FW NOTE]: number of branching actions: 8

ivy_to_cpp target=qrm simple-decentralized-lock.node_2.finite.ivy

[IVY_TO_CPP RESULT]: OK

swig -c++ -python -o simple-decentralized-lock.node_2.finite_wrap.cpp ivy_exec.i

[SWIG RESULT]: OK

g++ -std=c++11 -fpic -pthread -O3 simple-decentralized-lock.node_2.finite.cpp simple-decentralized-lock.node_2.finite_wrap.cpp -I/home/yunrong/.pyenv/versions/3.12.0/include/python3.12 -c

[G++ RESULT]: OK

g++ -shared simple-decentralized-lock.node_2.finite.o simple-decentralized-lock.node_2.finite_wrap.o -o _ivy_exec.so -lm -lstdc++

[LINK RESULT]: OK

[QRM NOTE]: Time elapsed since start: 6.477 seconds

[QRM NOTE]: Time elapsed since last: 6.477 seconds

[QRM NOTE]: Peak memory: 1175096 bytes


===================================

	Forward reachability

===================================

[FW NOTE]: dfs max depth: 3

[FW NOTE]: number of total reachable states:        12

[FW NOTE]: number of dfs representative states:     6

[FW NOTE]: number of dfs non-representative states: 6


=====================================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_1.0.ivy: node=2]

=====================================================================================================================

sort: node=['node0', 'node1']
predicate: has_lock('node',)
predicate: start_node=('node',)
predicate: message('node', 'node')
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'has_lock(node1)', 'message(node0,node0)', 'message(node0,node1)', 'message(node1,node0)', 'message(node1,node1)', '(start_node=node0)', '(start_node=node1)']
representative states : 65, 5, 9, 66, 10, 6


=== State Orbit 0 =====================
size : 2
repr state: 10000010
lex min decimal: 65
states:
10000010
01000001




=== State Orbit 1 =====================
size : 2
repr state: 00100010
lex min decimal: 5
states:
00000101
00100010




=== State Orbit 2 =====================
size : 2
repr state: 00010010
lex min decimal: 9
states:
00001001
00010010




=== State Orbit 3 =====================
size : 2
repr state: 01000010
lex min decimal: 66
states:
10000001
01000010




=== State Orbit 4 =====================
size : 2
repr state: 00001010
lex min decimal: 10
states:
00010001
00001010




=== State Orbit 5 =====================
size : 2
repr state: 00000110
lex min decimal: 6
states:
00000110
00100001



[QRM NOTE]: Time elapsed since start: 6.549 seconds

[QRM NOTE]: Time elapsed since last: 0.072 seconds

[QRM NOTE]: Peak memory: 1204629 bytes


==========================================================================================================================================

	[REACH_CHECK]: Reachability Convergence Check for Rmin on [ivybench/sym/ivy/simple-decentralized-lock.node_1.0.ivy: node=2]

==========================================================================================================================================

Found a representative state in Rmin not in reachability: decimal: 217, binary: 11011001

Found a representative state in Rmin not in reachability: decimal: 37, binary: 00100101

Found a representative state in Rmin not in reachability: decimal: 193, binary: 11000001

Found a representative state in Rmin not in reachability: decimal: 61, binary: 00111101

Found a representative state in Rmin not in reachability: decimal: 46, binary: 00101110

Found a representative state in Rmin not in reachability: decimal: 122, binary: 01111010

Found a representative state in Rmin not in reachability: decimal: 114, binary: 01110010

Found a representative state in Rmin not in reachability: decimal: 45, binary: 00101101

Found a representative state in Rmin not in reachability: decimal: 98, binary: 01100010

Found a representative state in Rmin not in reachability: decimal: 106, binary: 01101010

Found a representative state in Rmin not in reachability: decimal: 113, binary: 01110001

Found a representative state in Rmin not in reachability: decimal: 121, binary: 01111001

Found a representative state in Rmin not in reachability: decimal: 202, binary: 11001010

Found a representative state in Rmin not in reachability: decimal: 97, binary: 01100001

Found a representative state in Rmin not in reachability: decimal: 105, binary: 01101001

Found a representative state in Rmin not in reachability: decimal: 201, binary: 11001001

Representatitive states in reachability not in Rmin

{65, 66, 5, 6, 9, 10}

[REACH_CHECK RESULT]: FAIL

[QRM NOTE]: Time elapsed since start: 6.558 seconds

[QRM NOTE]: Time elapsed since last: 0.009 seconds

[QRM NOTE]: Peak memory: 158264 bytes

next size: node=2


***********************************************************************************************

	[Synthesize Rmin]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

***********************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.ivy -s node=2 -f 1 -g -w -r -m -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


---------- Initializing reachability from file ----------

OK


======================================

	Reduce Equivalent Atoms

======================================

[FW NOTE]: equivalent atoms

[FW NOTE]: complement atoms

[FW NOTE]: remove_atom_ids: set()

[QRM NOTE]: Time elapsed since start: 0.016 seconds

[QRM NOTE]: Time elapsed since last: 0.016 seconds

[QRM NOTE]: Peak memory: 3016 bytes


============================================================================================================

	[PRIME]: Prime Orbit Generatation on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

============================================================================================================


=======================================================================================================

	[PRIME RESULT]: Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

=======================================================================================================


=== Prime Orbit 0 =====================
size : 1
num_suborbits: 1
0 (*) : ------00
0     : ['~(start_node=node0)', '~(start_node=node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 1 =====================
size : 2
num_suborbits: 1
1 (*) : ----11--
1     : ['message(node1,node0)', 'message(node1,node1)']
2     : --11----
2     : ['message(node0,node0)', 'message(node0,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 2 =====================
size : 2
num_suborbits: 1
3 (*) : -1--1---
3     : ['has_lock(node1)', 'message(node1,node0)']
4     : 1--1----
4     : ['has_lock(node0)', 'message(node0,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 3 =====================
size : 2
num_suborbits: 1
5 (*) : 1---1---
5     : ['has_lock(node0)', 'message(node1,node0)']
6     : -1-1----
6     : ['has_lock(node1)', 'message(node0,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 4 =====================
size : 2
num_suborbits: 1
7 (*) : --1-1---
7     : ['message(node0,node0)', 'message(node1,node0)']
8     : ---1-1--
8     : ['message(node0,node1)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
9 (*) : ---11---
9     : ['message(node0,node1)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 6 =====================
size : 1
num_suborbits: 1
10 (*) : ------11
10     : ['(start_node=node0)', '(start_node=node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 7 =====================
size : 1
num_suborbits: 1
11 (*) : 11------
11     : ['has_lock(node0)', 'has_lock(node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 8 =====================
size : 2
num_suborbits: 1
12 (*) : 1-1-----
12     : ['has_lock(node0)', 'message(node0,node0)']
13     : -1---1--
13     : ['has_lock(node1)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 9 =====================
size : 2
num_suborbits: 1
14 (*) : -11-----
14     : ['has_lock(node1)', 'message(node0,node0)']
15     : 1----1--
15     : ['has_lock(node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 10 =====================
size : 1
num_suborbits: 1
16 (*) : --1--1--
16     : ['message(node0,node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 11 =====================
size : 1
num_suborbits: 1
17 (*) : 000000--
17     : ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0



[PRIME NOTE]: number of orbits after merging: 12

[PRIME NOTE]: number of orbits before merging: 12

[PRIME NOTE]: number of primes: 18

[QRM NOTE]: Time elapsed since start: 0.029 seconds

[QRM NOTE]: Time elapsed since last: 0.014 seconds

[QRM NOTE]: Peak memory: 1095779 bytes


=================================================================================================

	[RED]: PRIME REDUCTION on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

=================================================================================================

definition primes: {0, 6}


New level: 0
 pending : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]
 solution : []


Before reduction : 
 pending  : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]
 solution : []

Essensial at level 0 : {1, 2, 3, 4, 5, 7, 8, 9, 10, 11}

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]


Before reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]

Essensial at level 0 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]

[QRM NOTE]: Time elapsed since start: 0.031 seconds

[QRM NOTE]: Time elapsed since last: 0.002 seconds

[QRM NOTE]: Peak memory: 47635 bytes


=====================================================================================================

	[QI]: Quantifier Inference on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

=====================================================================================================


---------- quantifier_inference ----------


=== Prime Orbit 1 =====================
size : 2
num_suborbits: 1
1 (*) : ----11--
1     : ['message(node1,node0)', 'message(node1,node1)']
2     : --11----
2     : ['message(node0,node0)', 'message(node0,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node1,node0)', 'message(node1,node1)']

sign_func_name2args: {'0$message': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$1], Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$1$0]}

sig2const: {'node$0$message$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['message(node1,node0)', 'message(node1,node1)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$0$1; node$0$message$1$1], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$message$0; node$0$message$0; node$0$message$1': node$0$message$0$0; node$0$message$0$1; node$0$message$1$1, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1


=== Prime Orbit 2 =====================
size : 2
num_suborbits: 1
3 (*) : -1--1---
3     : ['has_lock(node1)', 'message(node1,node0)']
4     : 1--1----
4     : ['has_lock(node0)', 'message(node0,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node1)', 'message(node1,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))),)], '0$message': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0, node$0$message$0$0], Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node1)', 'message(node1,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),), 'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$0': [node$0$has_lock$0$0; node$0$message$0$0], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$0': node$0$has_lock$0$0; node$0$message$0$0, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]], '0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE1)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE0,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1


=== Prime Orbit 3 =====================
size : 2
num_suborbits: 1
5 (*) : 1---1---
5     : ['has_lock(node0)', 'message(node1,node0)']
6     : -1-1----
6     : ['has_lock(node1)', 'message(node0,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node1,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))),)], '0$message': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0, node$0$message$1$0], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$1$0, node$0$message$0$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node1,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),), 'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$1$0, node$0$message$0$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$1': [node$0$has_lock$0$0; node$0$message$1$0], 'node$0$message$0': [node$0$message$0$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$1': node$0$has_lock$0$0; node$0$message$1$0, 'node$0$message$0': node$0$message$0$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE0)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE1,NODE0) | ~has_lock(NODE0) | NODE0 = NODE1


=== Prime Orbit 4 =====================
size : 2
num_suborbits: 1
7 (*) : --1-1---
7     : ['message(node0,node0)', 'message(node1,node0)']
8     : ---1-1--
8     : ['message(node0,node1)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node0)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$1$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$0; node$0$message$1$1, node$0$message$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$0; node$0$message$1$1 | node$0$message$0$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0; node$0$message$1$1 | node$0$message$0$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node0)', 'message(node1,node0)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$0; node$0$message$1$1, node$0$message$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$0; node$0$message$1$1 | node$0$message$0$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1; node$0$message$1': [node$0$message$0$0; node$0$message$1$0; node$0$message$1$1], 'node$0$message$0': [node$0$message$0$1]}

	identical_single_classes: {'node$0$message$0; node$0$message$1; node$0$message$1': node$0$message$0$0; node$0$message$1$0; node$0$message$1$1, 'node$0$message$0': node$0$message$0$1}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'message(NODE1,NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1


=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
9 (*) : ---11---
9     : ['message(node0,node1)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$1$0, node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['message(node0,node1)', 'message(node1,node0)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0, node$0$message$1$1, node$0$message$0$1, node$0$message$1$0]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE0)', 'message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE1,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1


=== Prime Orbit 7 =====================
size : 1
num_suborbits: 1
11 (*) : 11------
11     : ['has_lock(node0)', 'has_lock(node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'has_lock(node1)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))),)]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$1]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

part_sig: ('node$0$has_lock$0$0 | node$0$has_lock$0$1',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'has_lock(node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),)}

sign_func_name2count:  {'0$has_lock': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: set()

exists_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: exists NODE0. ~has_lock(NODE0)


=== Prime Orbit 8 =====================
size : 2
num_suborbits: 1
12 (*) : 1-1-----
12     : ['has_lock(node0)', 'message(node0,node0)']
13     : -1---1--
13     : ['has_lock(node1)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node0,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node0,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),), 'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]], '0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0)


=== Prime Orbit 9 =====================
size : 2
num_suborbits: 1
14 (*) : -11-----
14     : ['has_lock(node1)', 'message(node0,node0)']
15     : 1----1--
15     : ['has_lock(node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node1)', 'message(node0,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node1', EnumeratedSort('node', ('node0', 'node1'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$has_lock$0$0], Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0, node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node1)', 'message(node0,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),), 'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$has_lock$0$0, node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0], 'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0': node$0$has_lock$0$0, 'node$0$message$0; node$0$message$1': node$0$message$0$0; node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE1)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE1,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1


=== Prime Orbit 10 =====================
size : 1
num_suborbits: 1
16 (*) : --1--1--
16     : ['message(node0,node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node0)', 'message(node1,node1)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$0, node$0$message$1$0], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$0$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node0)', 'message(node1,node1)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0, node$0$message$1$0, node$0$message$0$1, node$0$message$1$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'message(NODE1,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1


=== Prime Orbit 11 =====================
size : 1
num_suborbits: 1
17 (*) : 000000--
17     : ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']

sign_func_name2args: {'1$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))),)], '1$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node0', EnumeratedSort('node', ('node0', 'node1')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1'))), Const('node1', EnumeratedSort('node', ('node0', 'node1'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1'))): [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$1$0, node$1$message$0$1, node$1$message$1$2], Const('node1', EnumeratedSort('node', ('node0', 'node1'))): [node$1$has_lock$0$1, node$1$message$1$1, node$1$message$0$2, node$1$message$0$3, node$1$message$1$3]}

sig2const: {'node$1$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$0$1': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$0$2': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$1$2': Const('node0', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$0$3': Const('node1', EnumeratedSort('node', ('node0', 'node1'))), 'node$1$message$1$3': Const('node1', EnumeratedSort('node', ('node0', 'node1')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2, node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2 | node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3}

part_sig: ('node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2 | node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3',)


---------- SigGenerator ----------

terms:  ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1')),), 'message': (EnumeratedSort('node', ('node0', 'node1')), EnumeratedSort('node', ('node0', 'node1')))}

sign_func_name2count:  {'1$has_lock': 2, '1$message': 4}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2, node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2 | node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3}

	sort: node

	identical_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$1$0; node$1$message$1$2, node$1$has_lock$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$1; node$1$message$1$3]}

	identical_single_classes: {}

	identical_multi_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$0$1, node$1$message$1$0, node$1$message$1$2, node$1$has_lock$0$1, node$1$message$0$2, node$1$message$0$3, node$1$message$1$1, node$1$message$1$3]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: set()

exists_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'1$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1')))]], '1$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['~has_lock(NODE0)', '~message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: exists NODE1,NODE0. has_lock(NODE0) | message(NODE0,NODE1)


===============================================================================================================

	[QI RESULT]: Quantified Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

===============================================================================================================


=== Prime Orbit 1 =====================
size : 2
num_suborbits: 1
1 (*) : ----11--
1     : ['message(node1,node0)', 'message(node1,node1)']
2     : --11----
2     : ['message(node0,node0)', 'message(node0,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 2 =====================
size : 2
num_suborbits: 1
3 (*) : -1--1---
3     : ['has_lock(node1)', 'message(node1,node0)']
4     : 1--1----
4     : ['has_lock(node0)', 'message(node0,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE0,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 3 =====================
size : 2
num_suborbits: 1
5 (*) : 1---1---
5     : ['has_lock(node0)', 'message(node1,node0)']
6     : -1-1----
6     : ['has_lock(node1)', 'message(node0,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE1,NODE0) | ~has_lock(NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 4 =====================
size : 2
num_suborbits: 1
7 (*) : --1-1---
7     : ['message(node0,node0)', 'message(node1,node0)']
8     : ---1-1--
8     : ['message(node0,node1)', 'message(node1,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 5 =====================
size : 1
num_suborbits: 1
9 (*) : ---11---
9     : ['message(node0,node1)', 'message(node1,node0)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE1,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 7 =====================
size : 1
num_suborbits: 1
11 (*) : 11------
11     : ['has_lock(node0)', 'has_lock(node1)']
num_forall :   0
num_exists :   1
num_literals : 1
quantified form : exists NODE0. ~has_lock(NODE0)
qcost : 2




=== Prime Orbit 8 =====================
size : 2
num_suborbits: 1
12 (*) : 1-1-----
12     : ['has_lock(node0)', 'message(node0,node0)']
13     : -1---1--
13     : ['has_lock(node1)', 'message(node1,node1)']
num_forall :   1
num_exists :   0
num_literals : 2
quantified form : forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0)
qcost : 3




=== Prime Orbit 9 =====================
size : 2
num_suborbits: 1
14 (*) : -11-----
14     : ['has_lock(node1)', 'message(node0,node0)']
15     : 1----1--
15     : ['has_lock(node0)', 'message(node1,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE1,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 10 =====================
size : 1
num_suborbits: 1
16 (*) : --1--1--
16     : ['message(node0,node0)', 'message(node1,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 11 =====================
size : 1
num_suborbits: 1
17 (*) : 000000--
17     : ['~has_lock(node0)', '~has_lock(node1)', '~message(node0,node0)', '~message(node0,node1)', '~message(node1,node0)', '~message(node1,node1)']
num_forall :   0
num_exists :   2
num_literals : 2
quantified form : exists NODE1,NODE0. has_lock(NODE0) | message(NODE0,NODE1)
qcost : 4



[QRM NOTE]: Time elapsed since start: 0.132 seconds

[QRM NOTE]: Time elapsed since last: 0.101 seconds

[QRM NOTE]: Peak memory: 1808768 bytes


==============================================================================================

	[MIN]: Minimization on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

==============================================================================================


New level: 1
 pending : []
 solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]


Before reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]

Essensial at level 1 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1)]

Covered at level 1 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]


Solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11] has cost 44.


Before backtrack at level 1
 pending : []
 solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]

After backtrack at level 1
 pending : []
 solution : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]


=============================================================================================================

	[MIN RESULT]: Minimized Invariants on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

=============================================================================================================

[MIN NOTE]: number of minimal solution found: 1

[MIN NOTE]: upper bound: 44

[MIN NOTE]: maximum branch and bound depth: 1

[MIN NOTE]: number of definitions: 0

[MIN NOTE]: number of equality relations: 0

[MIN NOTE]: Solution 0 : [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]

[MIN NOTE]: solution length: 10

invariant [invar_1] forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_2] forall NODE1,NODE0. ~message(NODE0,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_3] forall NODE1,NODE0. ~message(NODE1,NODE0) | ~has_lock(NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_4] forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_5] forall NODE1,NODE0. ~message(NODE1,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_7] exists NODE0. ~has_lock(NODE0) # qcost: 2

invariant [invar_8] forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0) # qcost: 3

invariant [invar_9] forall NODE1,NODE0. ~message(NODE1,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_10] forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_11] exists NODE1,NODE0. has_lock(NODE0) | message(NODE0,NODE1) # qcost: 4

[MIN NOTE]: number of total invariants: 10

[MIN NOTE]: total qCost: 44




[QRM NOTE]: Time elapsed since start: 0.188 seconds

[QRM NOTE]: Time elapsed since last: 0.056 seconds

[QRM NOTE]: Peak memory: 1789092 bytes


**************************************************************************************************************

	[Reachability Convergence Check]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=2]

**************************************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.node_2.0.ivy -s node=3 -f 2 -g -w -r -m -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


==============================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_2.0.ivy: node=3]

==============================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 15

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 6

[FW NOTE]: number of branching actions: 18

ivy_to_cpp target=qrm simple-decentralized-lock.node_3.finite.ivy

[IVY_TO_CPP RESULT]: OK

swig -c++ -python -o simple-decentralized-lock.node_3.finite_wrap.cpp ivy_exec.i

[SWIG RESULT]: OK

g++ -std=c++11 -fpic -pthread -O3 simple-decentralized-lock.node_3.finite.cpp simple-decentralized-lock.node_3.finite_wrap.cpp -I/home/yunrong/.pyenv/versions/3.12.0/include/python3.12 -c

[G++ RESULT]: OK

g++ -shared simple-decentralized-lock.node_3.finite.o simple-decentralized-lock.node_3.finite_wrap.o -o _ivy_exec.so -lm -lstdc++

[LINK RESULT]: OK

[QRM NOTE]: Time elapsed since start: 6.848 seconds

[QRM NOTE]: Time elapsed since last: 6.848 seconds

[QRM NOTE]: Peak memory: 1177217 bytes


===================================

	Forward reachability

===================================

[FW NOTE]: dfs max depth: 3

[FW NOTE]: number of total reachable states:        36

[FW NOTE]: number of dfs representative states:     7

[FW NOTE]: number of dfs non-representative states: 29


=====================================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_2.0.ivy: node=3]

=====================================================================================================================

sort: node=['node0', 'node1', 'node2']
predicate: has_lock('node',)
predicate: start_node=('node',)
predicate: message('node', 'node')
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'has_lock(node1)', 'has_lock(node2)', 'message(node0,node0)', 'message(node0,node1)', 'message(node0,node2)', 'message(node1,node0)', 'message(node1,node1)', 'message(node1,node2)', 'message(node2,node0)', 'message(node2,node1)', 'message(node2,node2)', '(start_node=node0)', '(start_node=node1)', '(start_node=node2)']
representative states : 4097, 9, 17, 4098, 18, 10, 20


=== State Orbit 0 =====================
size : 3
repr state: 100000000000100
lex min decimal: 4097
states:
001000000000001
100000000000100
010000000000010




=== State Orbit 1 =====================
size : 3
repr state: 000100000000100
lex min decimal: 9
states:
000100000000100
000000000001001
000000010000010




=== State Orbit 2 =====================
size : 6
repr state: 000010000000100
lex min decimal: 17
states:
000010000000100
000000000100001
000000100000010
000000001000010
000001000000100
000000000010001




=== State Orbit 3 =====================
size : 6
repr state: 010000000000100
lex min decimal: 4098
states:
010000000000100
100000000000010
001000000000010
100000000000001
001000000000100
010000000000001




=== State Orbit 4 =====================
size : 6
repr state: 000000100000100
lex min decimal: 18
states:
000001000000001
000000000010010
000000100000100
000010000000010
000000001000001
000000000100100




=== State Orbit 5 =====================
size : 6
repr state: 000000010000100
lex min decimal: 10
states:
000000010000001
000100000000010
000000000001100
000000010000100
000000000001010
000100000000001




=== State Orbit 6 =====================
size : 6
repr state: 000000001000100
lex min decimal: 20
states:
000000100000001
000000001000100
000001000000010
000010000000001
000000000010100
000000000100010



[QRM NOTE]: Time elapsed since start: 6.934 seconds

[QRM NOTE]: Time elapsed since last: 0.086 seconds

[QRM NOTE]: Peak memory: 1215976 bytes


==========================================================================================================================================

	[REACH_CHECK]: Reachability Convergence Check for Rmin on [ivybench/sym/ivy/simple-decentralized-lock.node_2.0.ivy: node=3]

==========================================================================================================================================

Found a representative state in Rmin not in reachability: decimal: 12289, binary: 011000000000001

Found a representative state in Rmin not in reachability: decimal: 12292, binary: 011000000000100

Found a representative state in Rmin not in reachability: decimal: 4353, binary: 001000100000001

Found a representative state in Rmin not in reachability: decimal: 4356, binary: 001000100000100

Found a representative state in Rmin not in reachability: decimal: 4354, binary: 001000100000010

Found a representative state in Rmin not in reachability: decimal: 289, binary: 000000100100001

Found a representative state in Rmin not in reachability: decimal: 98, binary: 000000001100010

Found a representative state in Rmin not in reachability: decimal: 161, binary: 000000010100001

Found a representative state in Rmin not in reachability: decimal: 97, binary: 000000001100001

Found a representative state in Rmin not in reachability: decimal: 785, binary: 000001100010001

Found a representative state in Rmin not in reachability: decimal: 306, binary: 000000100110010

Found a representative state in Rmin not in reachability: decimal: 305, binary: 000000100110001

Found a representative state in Rmin not in reachability: decimal: 49, binary: 000000000110001

Found a representative state in Rmin not in reachability: decimal: 50, binary: 000000000110010

Found a representative state in Rmin not in reachability: decimal: 308, binary: 000000100110100

Found a representative state in Rmin not in reachability: decimal: 292, binary: 000000100100100

Found a representative state in Rmin not in reachability: decimal: 164, binary: 000000010100100

Found a representative state in Rmin not in reachability: decimal: 100, binary: 000000001100100

Found a representative state in Rmin not in reachability: decimal: 162, binary: 000000010100010

[REACH_CHECK RESULT]: FAIL

[QRM NOTE]: Time elapsed since start: 7.027 seconds

[QRM NOTE]: Time elapsed since last: 0.093 seconds

[QRM NOTE]: Peak memory: 225509 bytes

next size: node=3


***********************************************************************************************

	[Synthesize Rmin]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

***********************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.ivy -s node=3 -f 1 -g -w -r -m -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


---------- Initializing reachability from file ----------

OK


======================================

	Reduce Equivalent Atoms

======================================

[FW NOTE]: equivalent atoms

[FW NOTE]: complement atoms

[FW NOTE]: remove_atom_ids: set()

[QRM NOTE]: Time elapsed since start: 0.015 seconds

[QRM NOTE]: Time elapsed since last: 0.015 seconds

[QRM NOTE]: Peak memory: 10540 bytes


============================================================================================================

	[PRIME]: Prime Orbit Generatation on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

============================================================================================================


=======================================================================================================

	[PRIME RESULT]: Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

=======================================================================================================


=== Prime Orbit 0 =====================
size : 3
num_suborbits: 1
0 (*) : ------------1-1
0     : ['(start_node=node0)', '(start_node=node2)']
1     : ------------11-
1     : ['(start_node=node0)', '(start_node=node1)']
2     : -------------11
2     : ['(start_node=node1)', '(start_node=node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 1 =====================
size : 3
num_suborbits: 1
3 (*) : ---1-------1---
3     : ['message(node0,node0)', 'message(node2,node2)']
4     : ---1---1-------
4     : ['message(node0,node0)', 'message(node1,node1)']
5     : -------1---1---
5     : ['message(node1,node1)', 'message(node2,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 2 =====================
size : 6
num_suborbits: 1
6 (*) : 1----------1---
6     : ['has_lock(node0)', 'message(node2,node2)']
7     : 1------1-------
7     : ['has_lock(node0)', 'message(node1,node1)']
8     : -1---------1---
8     : ['has_lock(node1)', 'message(node2,node2)']
9     : -1-1-----------
9     : ['has_lock(node1)', 'message(node0,node0)']
10     : --1----1-------
10     : ['has_lock(node2)', 'message(node1,node1)']
11     : --11-----------
11     : ['has_lock(node2)', 'message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 3 =====================
size : 3
num_suborbits: 1
12 (*) : --1--------1---
12     : ['has_lock(node2)', 'message(node2,node2)']
13     : -1-----1-------
13     : ['has_lock(node1)', 'message(node1,node1)']
14     : 1--1-----------
14     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 4 =====================
size : 6
num_suborbits: 1
15 (*) : ----1------1---
15     : ['message(node0,node1)', 'message(node2,node2)']
16     : -----1-1-------
16     : ['message(node0,node2)', 'message(node1,node1)']
17     : ------1----1---
17     : ['message(node1,node0)', 'message(node2,node2)']
18     : ---1----1------
18     : ['message(node0,node0)', 'message(node1,node2)']
19     : -------1-1-----
19     : ['message(node1,node1)', 'message(node2,node0)']
20     : ---1------1----
20     : ['message(node0,node0)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 5 =====================
size : 6
num_suborbits: 1
21 (*) : -----1-----1---
21     : ['message(node0,node2)', 'message(node2,node2)']
22     : ----1--1-------
22     : ['message(node0,node1)', 'message(node1,node1)']
23     : --------1--1---
23     : ['message(node1,node2)', 'message(node2,node2)']
24     : ---1--1--------
24     : ['message(node0,node0)', 'message(node1,node0)']
25     : -------1--1----
25     : ['message(node1,node1)', 'message(node2,node1)']
26     : ---1-----1-----
26     : ['message(node0,node0)', 'message(node2,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 6 =====================
size : 6
num_suborbits: 1
27 (*) : ---------1-1---
27     : ['message(node2,node0)', 'message(node2,node2)']
28     : ------11-------
28     : ['message(node1,node0)', 'message(node1,node1)']
29     : ----------11---
29     : ['message(node2,node1)', 'message(node2,node2)']
30     : ---11----------
30     : ['message(node0,node0)', 'message(node0,node1)']
31     : -------11------
31     : ['message(node1,node1)', 'message(node1,node2)']
32     : ---1-1---------
32     : ['message(node0,node0)', 'message(node0,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 7 =====================
size : 3
num_suborbits: 1
33 (*) : 11-------------
33     : ['has_lock(node0)', 'has_lock(node1)']
34     : 1-1------------
34     : ['has_lock(node0)', 'has_lock(node2)']
35     : -11------------
35     : ['has_lock(node1)', 'has_lock(node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 8 =====================
size : 6
num_suborbits: 1
36 (*) : --1-1----------
36     : ['has_lock(node2)', 'message(node0,node1)']
37     : -1---1---------
37     : ['has_lock(node1)', 'message(node0,node2)']
38     : --1---1--------
38     : ['has_lock(node2)', 'message(node1,node0)']
39     : 1-------1------
39     : ['has_lock(node0)', 'message(node1,node2)']
40     : -1-------1-----
40     : ['has_lock(node1)', 'message(node2,node0)']
41     : 1---------1----
41     : ['has_lock(node0)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 9 =====================
size : 6
num_suborbits: 1
42 (*) : -1--1----------
42     : ['has_lock(node1)', 'message(node0,node1)']
43     : --1--1---------
43     : ['has_lock(node2)', 'message(node0,node2)']
44     : 1-----1--------
44     : ['has_lock(node0)', 'message(node1,node0)']
45     : --1-----1------
45     : ['has_lock(node2)', 'message(node1,node2)']
46     : 1--------1-----
46     : ['has_lock(node0)', 'message(node2,node0)']
47     : -1--------1----
47     : ['has_lock(node1)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 10 =====================
size : 6
num_suborbits: 1
48 (*) : 1---1----------
48     : ['has_lock(node0)', 'message(node0,node1)']
49     : 1----1---------
49     : ['has_lock(node0)', 'message(node0,node2)']
50     : -1----1--------
50     : ['has_lock(node1)', 'message(node1,node0)']
51     : -1------1------
51     : ['has_lock(node1)', 'message(node1,node2)']
52     : --1------1-----
52     : ['has_lock(node2)', 'message(node2,node0)']
53     : --1-------1----
53     : ['has_lock(node2)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 11 =====================
size : 3
num_suborbits: 1
54 (*) : ----11---------
54     : ['message(node0,node1)', 'message(node0,node2)']
55     : ------1-1------
55     : ['message(node1,node0)', 'message(node1,node2)']
56     : ---------11----
56     : ['message(node2,node0)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 12 =====================
size : 6
num_suborbits: 1
57 (*) : -----11--------
57     : ['message(node0,node2)', 'message(node1,node0)']
58     : ----1----1-----
58     : ['message(node0,node1)', 'message(node2,node0)']
59     : ----1---1------
59     : ['message(node0,node1)', 'message(node1,node2)']
60     : ------1---1----
60     : ['message(node1,node0)', 'message(node2,node1)']
61     : -----1----1----
61     : ['message(node0,node2)', 'message(node2,node1)']
62     : --------11-----
62     : ['message(node1,node2)', 'message(node2,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 13 =====================
size : 3
num_suborbits: 1
63 (*) : ----1-1--------
63     : ['message(node0,node1)', 'message(node1,node0)']
64     : -----1---1-----
64     : ['message(node0,node2)', 'message(node2,node0)']
65     : --------1-1----
65     : ['message(node1,node2)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 14 =====================
size : 3
num_suborbits: 1
66 (*) : -----1--1------
66     : ['message(node0,node2)', 'message(node1,node2)']
67     : ----1-----1----
67     : ['message(node0,node1)', 'message(node2,node1)']
68     : ------1--1-----
68     : ['message(node1,node0)', 'message(node2,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 15 =====================
size : 1
num_suborbits: 1
69 (*) : ------------000
69     : ['~(start_node=node0)', '~(start_node=node1)', '~(start_node=node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 16 =====================
size : 1
num_suborbits: 1
70 (*) : 000000000000---
70     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0



[PRIME NOTE]: number of orbits after merging: 17

[PRIME NOTE]: number of orbits before merging: 17

[PRIME NOTE]: number of primes: 71

[QRM NOTE]: Time elapsed since start: 0.038 seconds

[QRM NOTE]: Time elapsed since last: 0.023 seconds

[QRM NOTE]: Peak memory: 1185205 bytes


=================================================================================================

	[RED]: PRIME REDUCTION on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

=================================================================================================

definition primes: {0, 15}


New level: 0
 pending : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]
 solution : []


Before reduction : 
 pending  : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]
 solution : []

Essensial at level 0 : {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16}

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]


Before reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]

Essensial at level 0 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]

[QRM NOTE]: Time elapsed since start: 0.040 seconds

[QRM NOTE]: Time elapsed since last: 0.002 seconds

[QRM NOTE]: Peak memory: 137226 bytes


=====================================================================================================

	[QI]: Quantifier Inference on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

=====================================================================================================


---------- quantifier_inference ----------


=== Prime Orbit 1 =====================
size : 3
num_suborbits: 1
3 (*) : ---1-------1---
3     : ['message(node0,node0)', 'message(node2,node2)']
4     : ---1---1-------
4     : ['message(node0,node0)', 'message(node1,node1)']
5     : -------1---1---
5     : ['message(node1,node1)', 'message(node2,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node0)', 'message(node2,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node0)', 'message(node2,node2)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0, node$0$message$1$0, node$0$message$0$1, node$0$message$1$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'message(NODE1,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE1. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1


=== Prime Orbit 2 =====================
size : 6
num_suborbits: 1
6 (*) : 1----------1---
6     : ['has_lock(node0)', 'message(node2,node2)']
7     : 1------1-------
7     : ['has_lock(node0)', 'message(node1,node1)']
8     : -1---------1---
8     : ['has_lock(node1)', 'message(node2,node2)']
9     : -1-1-----------
9     : ['has_lock(node1)', 'message(node0,node0)']
10     : --1----1-------
10     : ['has_lock(node2)', 'message(node1,node1)']
11     : --11-----------
11     : ['has_lock(node2)', 'message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node2,node2)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node2,node2)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0], 'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0': node$0$has_lock$0$0, 'node$0$message$0; node$0$message$1': node$0$message$0$0; node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE1)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE1. ~message(NODE1,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1


=== Prime Orbit 3 =====================
size : 3
num_suborbits: 1
12 (*) : --1--------1---
12     : ['has_lock(node2)', 'message(node2,node2)']
13     : -1-----1-------
13     : ['has_lock(node1)', 'message(node1,node1)']
14     : 1--1-----------
14     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node2)', 'message(node2,node2)']

sign_func_name2args: {'0$has_lock': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node2)', 'message(node2,node2)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]], '0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0)


=== Prime Orbit 4 =====================
size : 6
num_suborbits: 1
15 (*) : ----1------1---
15     : ['message(node0,node1)', 'message(node2,node2)']
16     : -----1-1-------
16     : ['message(node0,node2)', 'message(node1,node1)']
17     : ------1----1---
17     : ['message(node1,node0)', 'message(node2,node2)']
18     : ---1----1------
18     : ['message(node0,node0)', 'message(node1,node2)']
19     : -------1-1-----
19     : ['message(node1,node1)', 'message(node2,node0)']
20     : ---1------1----
20     : ['message(node0,node0)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node2,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

part_sig: ('node$0$message$0$0 | node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['message(node0,node1)', 'message(node2,node2)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$message$0': [node$0$message$0$0], 'node$0$message$0; node$0$message$1': [node$0$message$0$1; node$0$message$1$1], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$message$0': node$0$message$0$0, 'node$0$message$0; node$0$message$1': node$0$message$0$1; node$0$message$1$1, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE2)', 'message(NODE1,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE2,NODE1. ~message(NODE0,NODE2) | ~message(NODE1,NODE1) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2)


=== Prime Orbit 5 =====================
size : 6
num_suborbits: 1
21 (*) : -----1-----1---
21     : ['message(node0,node2)', 'message(node2,node2)']
22     : ----1--1-------
22     : ['message(node0,node1)', 'message(node1,node1)']
23     : --------1--1---
23     : ['message(node1,node2)', 'message(node2,node2)']
24     : ---1--1--------
24     : ['message(node0,node0)', 'message(node1,node0)']
25     : -------1--1----
25     : ['message(node1,node1)', 'message(node2,node1)']
26     : ---1-----1-----
26     : ['message(node0,node0)', 'message(node2,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node2)', 'message(node2,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0, node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1; node$0$message$1$0; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1; node$0$message$1$0; node$0$message$1$1}

part_sig: ('node$0$message$0$0 | node$0$message$0$1; node$0$message$1$0; node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node2)', 'message(node2,node2)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1; node$0$message$1$0; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1; node$0$message$1$0; node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0': [node$0$message$0$0], 'node$0$message$0; node$0$message$1; node$0$message$1': [node$0$message$0$1; node$0$message$1$0; node$0$message$1$1]}

	identical_single_classes: {'node$0$message$0': node$0$message$0$0, 'node$0$message$0; node$0$message$1; node$0$message$1': node$0$message$0$1; node$0$message$1$0; node$0$message$1$1}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE1)', 'message(NODE1,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE1. ~message(NODE0,NODE1) | ~message(NODE1,NODE1) | NODE0 = NODE1


=== Prime Orbit 6 =====================
size : 6
num_suborbits: 1
27 (*) : ---------1-1---
27     : ['message(node2,node0)', 'message(node2,node2)']
28     : ------11-------
28     : ['message(node1,node0)', 'message(node1,node1)']
29     : ----------11---
29     : ['message(node2,node1)', 'message(node2,node2)']
30     : ---11----------
30     : ['message(node0,node0)', 'message(node0,node1)']
31     : -------11------
31     : ['message(node1,node1)', 'message(node1,node2)']
32     : ---1-1---------
32     : ['message(node0,node0)', 'message(node0,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node2,node0)', 'message(node2,node2)']

sign_func_name2args: {'0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$1], Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0]}

sig2const: {'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['message(node2,node0)', 'message(node2,node2)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$0$1; node$0$message$1$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$0$1; node$0$message$1$1 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$0$1; node$0$message$1$1], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$message$0; node$0$message$0; node$0$message$1': node$0$message$0$0; node$0$message$0$1; node$0$message$1$1, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE1. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1


=== Prime Orbit 7 =====================
size : 3
num_suborbits: 1
33 (*) : 11-------------
33     : ['has_lock(node0)', 'has_lock(node1)']
34     : 1-1------------
34     : ['has_lock(node0)', 'has_lock(node2)']
35     : -11------------
35     : ['has_lock(node1)', 'has_lock(node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'has_lock(node1)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$1]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

part_sig: ('node$0$has_lock$0$0 | node$0$has_lock$0$1',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'has_lock(node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),)}

sign_func_name2count:  {'0$has_lock': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE1)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE1. ~has_lock(NODE1) | ~has_lock(NODE0) | NODE0 = NODE1


=== Prime Orbit 8 =====================
size : 6
num_suborbits: 1
36 (*) : --1-1----------
36     : ['has_lock(node2)', 'message(node0,node1)']
37     : -1---1---------
37     : ['has_lock(node1)', 'message(node0,node2)']
38     : --1---1--------
38     : ['has_lock(node2)', 'message(node1,node0)']
39     : 1-------1------
39     : ['has_lock(node0)', 'message(node1,node2)']
40     : -1-------1-----
40     : ['has_lock(node1)', 'message(node2,node0)']
41     : 1---------1----
41     : ['has_lock(node0)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node2)', 'message(node0,node1)']

sign_func_name2args: {'0$has_lock': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0], Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node2)', 'message(node0,node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0], 'node$0$message$0': [node$0$message$0$0], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0': node$0$has_lock$0$0, 'node$0$message$0': node$0$message$0$0, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE2)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE2,NODE1. ~message(NODE1,NODE2) | ~has_lock(NODE0) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2)


=== Prime Orbit 9 =====================
size : 6
num_suborbits: 1
42 (*) : -1--1----------
42     : ['has_lock(node1)', 'message(node0,node1)']
43     : --1--1---------
43     : ['has_lock(node2)', 'message(node0,node2)']
44     : 1-----1--------
44     : ['has_lock(node0)', 'message(node1,node0)']
45     : --1-----1------
45     : ['has_lock(node2)', 'message(node1,node2)']
46     : 1--------1-----
46     : ['has_lock(node0)', 'message(node2,node0)']
47     : -1--------1----
47     : ['has_lock(node1)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node1)', 'message(node0,node1)']

sign_func_name2args: {'0$has_lock': [(Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0, node$0$message$1$0], Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0]}

sig2const: {'node$0$has_lock$0$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$1$0, node$0$message$0$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node1)', 'message(node0,node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$1$0, node$0$message$0$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$1': [node$0$has_lock$0$0; node$0$message$1$0], 'node$0$message$0': [node$0$message$0$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$1': node$0$has_lock$0$0; node$0$message$1$0, 'node$0$message$0': node$0$message$0$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE0)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE1. ~message(NODE1,NODE0) | ~has_lock(NODE0) | NODE0 = NODE1


=== Prime Orbit 10 =====================
size : 6
num_suborbits: 1
48 (*) : 1---1----------
48     : ['has_lock(node0)', 'message(node0,node1)']
49     : 1----1---------
49     : ['has_lock(node0)', 'message(node0,node2)']
50     : -1----1--------
50     : ['has_lock(node1)', 'message(node1,node0)']
51     : -1------1------
51     : ['has_lock(node1)', 'message(node1,node2)']
52     : --1------1-----
52     : ['has_lock(node2)', 'message(node2,node0)']
53     : --1-------1----
53     : ['has_lock(node2)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node0,node1)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$has_lock$0$0, node$0$message$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node0,node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$has_lock$0$0; node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$0': [node$0$has_lock$0$0; node$0$message$0$0], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$0': node$0$has_lock$0$0; node$0$message$0$0, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]], '0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE1)', 'has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE1. ~message(NODE0,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1


=== Prime Orbit 11 =====================
size : 3
num_suborbits: 1
54 (*) : ----11---------
54     : ['message(node0,node1)', 'message(node0,node2)']
55     : ------1-1------
55     : ['message(node1,node0)', 'message(node1,node2)']
56     : ---------11----
56     : ['message(node2,node0)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node0,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$0$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node1)', 'message(node0,node2)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$0': [node$0$message$0$0; node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}

	identical_single_classes: {'node$0$message$0; node$0$message$0': node$0$message$0$0; node$0$message$0$1}

	identical_multi_classes: {'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall_exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1. (exists NODE0. (~message(NODE1,NODE0) & NODE0 ~= NODE1))


=== Prime Orbit 12 =====================
size : 6
num_suborbits: 1
57 (*) : -----11--------
57     : ['message(node0,node2)', 'message(node1,node0)']
58     : ----1----1-----
58     : ['message(node0,node1)', 'message(node2,node0)']
59     : ----1---1------
59     : ['message(node0,node1)', 'message(node1,node2)']
60     : ------1---1----
60     : ['message(node1,node0)', 'message(node2,node1)']
61     : -----1----1----
61     : ['message(node0,node2)', 'message(node2,node1)']
62     : --------11-----
62     : ['message(node1,node2)', 'message(node2,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node2)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$1$1], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1 | node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['message(node0,node2)', 'message(node1,node0)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$1], 'node$0$message$0': [node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$message$0; node$0$message$1': node$0$message$0$0; node$0$message$1$1, 'node$0$message$0': node$0$message$0$1, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE0)', 'message(NODE0,NODE2)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE2,NODE1. ~message(NODE1,NODE0) | ~message(NODE0,NODE2) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2)


=== Prime Orbit 13 =====================
size : 3
num_suborbits: 1
63 (*) : ----1-1--------
63     : ['message(node0,node1)', 'message(node1,node0)']
64     : -----1---1-----
64     : ['message(node0,node2)', 'message(node2,node0)']
65     : --------1-1----
65     : ['message(node1,node2)', 'message(node2,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0, node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['message(node0,node1)', 'message(node1,node0)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0, node$0$message$1$1, node$0$message$0$1, node$0$message$1$0]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE1)', 'message(NODE1,NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0,NODE1. ~message(NODE0,NODE1) | ~message(NODE1,NODE0) | NODE0 = NODE1


=== Prime Orbit 14 =====================
size : 3
num_suborbits: 1
66 (*) : -----1--1------
66     : ['message(node0,node2)', 'message(node1,node2)']
67     : ----1-----1----
67     : ['message(node0,node1)', 'message(node2,node1)']
68     : ------1--1-----
68     : ['message(node1,node0)', 'message(node2,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node2)', 'message(node1,node2)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$1$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$0$message$1$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0; node$0$message$1$1}

part_sig: ('node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0; node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node2)', 'message(node1,node2)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0; node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1], 'node$0$message$1; node$0$message$1': [node$0$message$1$0; node$0$message$1$1]}

	identical_single_classes: {'node$0$message$1; node$0$message$1': node$0$message$1$0; node$0$message$1$1}

	identical_multi_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall_exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))}

exists_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1. (exists NODE0. (~message(NODE0,NODE1) & NODE0 ~= NODE1))


=== Prime Orbit 16 =====================
size : 1
num_suborbits: 1
70 (*) : 000000000000---
70     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']

sign_func_name2args: {'1$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))),), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))),)], '1$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$1$0, node$1$message$0$1, node$1$message$0$2, node$1$message$1$3, node$1$message$1$6], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$1$has_lock$0$1, node$1$message$1$1, node$1$message$0$3, node$1$message$0$4, node$1$message$1$4, node$1$message$0$5, node$1$message$1$7], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))): [node$1$has_lock$0$2, node$1$message$1$2, node$1$message$1$5, node$1$message$0$6, node$1$message$0$7, node$1$message$0$8, node$1$message$1$8]}

sig2const: {'node$1$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$has_lock$0$2': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$2': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$2': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$3': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$3': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$4': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$4': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$5': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$5': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$6': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$6': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$7': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$7': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$0$8': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2'))), 'node$1$message$1$8': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6, node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7, node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6 | node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7 | node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8}

part_sig: ('node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6 | node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7 | node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8',)


---------- SigGenerator ----------

terms:  ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2')), EnumeratedSort('node', ('node0', 'node1', 'node2')))}

sign_func_name2count:  {'1$has_lock': 3, '1$message': 9}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6, node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7, node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6 | node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7 | node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8}

	sort: node

	identical_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$1$0; node$1$message$1$3; node$1$message$1$6, node$1$has_lock$0$1; node$1$message$0$3; node$1$message$0$4; node$1$message$0$5; node$1$message$1$1; node$1$message$1$4; node$1$message$1$7, node$1$has_lock$0$2; node$1$message$0$6; node$1$message$0$7; node$1$message$0$8; node$1$message$1$2; node$1$message$1$5; node$1$message$1$8]}

	identical_single_classes: {}

	identical_multi_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$0$1, node$1$message$0$2, node$1$message$1$0, node$1$message$1$3, node$1$message$1$6, node$1$has_lock$0$1, node$1$message$0$3, node$1$message$0$4, node$1$message$0$5, node$1$message$1$1, node$1$message$1$4, node$1$message$1$7, node$1$has_lock$0$2, node$1$message$0$6, node$1$message$0$7, node$1$message$0$8, node$1$message$1$2, node$1$message$1$5, node$1$message$1$8]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: set()

exists_qvars: {Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'1$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2')))]], '1$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['~has_lock(NODE0)', '~message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: exists NODE0,NODE1. has_lock(NODE0) | message(NODE0,NODE1)


===============================================================================================================

	[QI RESULT]: Quantified Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

===============================================================================================================


=== Prime Orbit 1 =====================
size : 3
num_suborbits: 1
3 (*) : ---1-------1---
3     : ['message(node0,node0)', 'message(node2,node2)']
4     : ---1---1-------
4     : ['message(node0,node0)', 'message(node1,node1)']
5     : -------1---1---
5     : ['message(node1,node1)', 'message(node2,node2)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE0,NODE1. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 2 =====================
size : 6
num_suborbits: 1
6 (*) : 1----------1---
6     : ['has_lock(node0)', 'message(node2,node2)']
7     : 1------1-------
7     : ['has_lock(node0)', 'message(node1,node1)']
8     : -1---------1---
8     : ['has_lock(node1)', 'message(node2,node2)']
9     : -1-1-----------
9     : ['has_lock(node1)', 'message(node0,node0)']
10     : --1----1-------
10     : ['has_lock(node2)', 'message(node1,node1)']
11     : --11-----------
11     : ['has_lock(node2)', 'message(node0,node0)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE0,NODE1. ~message(NODE1,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 3 =====================
size : 3
num_suborbits: 1
12 (*) : --1--------1---
12     : ['has_lock(node2)', 'message(node2,node2)']
13     : -1-----1-------
13     : ['has_lock(node1)', 'message(node1,node1)']
14     : 1--1-----------
14     : ['has_lock(node0)', 'message(node0,node0)']
num_forall :   1
num_exists :   0
num_literals : 2
quantified form : forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0)
qcost : 3




=== Prime Orbit 4 =====================
size : 6
num_suborbits: 1
15 (*) : ----1------1---
15     : ['message(node0,node1)', 'message(node2,node2)']
16     : -----1-1-------
16     : ['message(node0,node2)', 'message(node1,node1)']
17     : ------1----1---
17     : ['message(node1,node0)', 'message(node2,node2)']
18     : ---1----1------
18     : ['message(node0,node0)', 'message(node1,node2)']
19     : -------1-1-----
19     : ['message(node1,node1)', 'message(node2,node0)']
20     : ---1------1----
20     : ['message(node0,node0)', 'message(node2,node1)']
num_forall :   3
num_exists :   0
num_literals : 5
quantified form : forall NODE0,NODE2,NODE1. ~message(NODE0,NODE2) | ~message(NODE1,NODE1) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2)
qcost : 8




=== Prime Orbit 5 =====================
size : 6
num_suborbits: 1
21 (*) : -----1-----1---
21     : ['message(node0,node2)', 'message(node2,node2)']
22     : ----1--1-------
22     : ['message(node0,node1)', 'message(node1,node1)']
23     : --------1--1---
23     : ['message(node1,node2)', 'message(node2,node2)']
24     : ---1--1--------
24     : ['message(node0,node0)', 'message(node1,node0)']
25     : -------1--1----
25     : ['message(node1,node1)', 'message(node2,node1)']
26     : ---1-----1-----
26     : ['message(node0,node0)', 'message(node2,node0)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE0,NODE1. ~message(NODE0,NODE1) | ~message(NODE1,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 6 =====================
size : 6
num_suborbits: 1
27 (*) : ---------1-1---
27     : ['message(node2,node0)', 'message(node2,node2)']
28     : ------11-------
28     : ['message(node1,node0)', 'message(node1,node1)']
29     : ----------11---
29     : ['message(node2,node1)', 'message(node2,node2)']
30     : ---11----------
30     : ['message(node0,node0)', 'message(node0,node1)']
31     : -------11------
31     : ['message(node1,node1)', 'message(node1,node2)']
32     : ---1-1---------
32     : ['message(node0,node0)', 'message(node0,node2)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE0,NODE1. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 7 =====================
size : 3
num_suborbits: 1
33 (*) : 11-------------
33     : ['has_lock(node0)', 'has_lock(node1)']
34     : 1-1------------
34     : ['has_lock(node0)', 'has_lock(node2)']
35     : -11------------
35     : ['has_lock(node1)', 'has_lock(node2)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE0,NODE1. ~has_lock(NODE1) | ~has_lock(NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 8 =====================
size : 6
num_suborbits: 1
36 (*) : --1-1----------
36     : ['has_lock(node2)', 'message(node0,node1)']
37     : -1---1---------
37     : ['has_lock(node1)', 'message(node0,node2)']
38     : --1---1--------
38     : ['has_lock(node2)', 'message(node1,node0)']
39     : 1-------1------
39     : ['has_lock(node0)', 'message(node1,node2)']
40     : -1-------1-----
40     : ['has_lock(node1)', 'message(node2,node0)']
41     : 1---------1----
41     : ['has_lock(node0)', 'message(node2,node1)']
num_forall :   3
num_exists :   0
num_literals : 5
quantified form : forall NODE0,NODE2,NODE1. ~message(NODE1,NODE2) | ~has_lock(NODE0) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2)
qcost : 8




=== Prime Orbit 9 =====================
size : 6
num_suborbits: 1
42 (*) : -1--1----------
42     : ['has_lock(node1)', 'message(node0,node1)']
43     : --1--1---------
43     : ['has_lock(node2)', 'message(node0,node2)']
44     : 1-----1--------
44     : ['has_lock(node0)', 'message(node1,node0)']
45     : --1-----1------
45     : ['has_lock(node2)', 'message(node1,node2)']
46     : 1--------1-----
46     : ['has_lock(node0)', 'message(node2,node0)']
47     : -1--------1----
47     : ['has_lock(node1)', 'message(node2,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE0,NODE1. ~message(NODE1,NODE0) | ~has_lock(NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 10 =====================
size : 6
num_suborbits: 1
48 (*) : 1---1----------
48     : ['has_lock(node0)', 'message(node0,node1)']
49     : 1----1---------
49     : ['has_lock(node0)', 'message(node0,node2)']
50     : -1----1--------
50     : ['has_lock(node1)', 'message(node1,node0)']
51     : -1------1------
51     : ['has_lock(node1)', 'message(node1,node2)']
52     : --1------1-----
52     : ['has_lock(node2)', 'message(node2,node0)']
53     : --1-------1----
53     : ['has_lock(node2)', 'message(node2,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE0,NODE1. ~message(NODE0,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 11 =====================
size : 3
num_suborbits: 1
54 (*) : ----11---------
54     : ['message(node0,node1)', 'message(node0,node2)']
55     : ------1-1------
55     : ['message(node1,node0)', 'message(node1,node2)']
56     : ---------11----
56     : ['message(node2,node0)', 'message(node2,node1)']
num_forall :   1
num_exists :   1
num_literals : 2
quantified form : forall NODE1. (exists NODE0. (~message(NODE1,NODE0) & NODE0 ~= NODE1))
qcost : 4




=== Prime Orbit 12 =====================
size : 6
num_suborbits: 1
57 (*) : -----11--------
57     : ['message(node0,node2)', 'message(node1,node0)']
58     : ----1----1-----
58     : ['message(node0,node1)', 'message(node2,node0)']
59     : ----1---1------
59     : ['message(node0,node1)', 'message(node1,node2)']
60     : ------1---1----
60     : ['message(node1,node0)', 'message(node2,node1)']
61     : -----1----1----
61     : ['message(node0,node2)', 'message(node2,node1)']
62     : --------11-----
62     : ['message(node1,node2)', 'message(node2,node0)']
num_forall :   3
num_exists :   0
num_literals : 5
quantified form : forall NODE0,NODE2,NODE1. ~message(NODE1,NODE0) | ~message(NODE0,NODE2) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2)
qcost : 8




=== Prime Orbit 13 =====================
size : 3
num_suborbits: 1
63 (*) : ----1-1--------
63     : ['message(node0,node1)', 'message(node1,node0)']
64     : -----1---1-----
64     : ['message(node0,node2)', 'message(node2,node0)']
65     : --------1-1----
65     : ['message(node1,node2)', 'message(node2,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE0,NODE1. ~message(NODE0,NODE1) | ~message(NODE1,NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 14 =====================
size : 3
num_suborbits: 1
66 (*) : -----1--1------
66     : ['message(node0,node2)', 'message(node1,node2)']
67     : ----1-----1----
67     : ['message(node0,node1)', 'message(node2,node1)']
68     : ------1--1-----
68     : ['message(node1,node0)', 'message(node2,node0)']
num_forall :   1
num_exists :   1
num_literals : 2
quantified form : forall NODE1. (exists NODE0. (~message(NODE0,NODE1) & NODE0 ~= NODE1))
qcost : 4




=== Prime Orbit 16 =====================
size : 1
num_suborbits: 1
70 (*) : 000000000000---
70     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)']
num_forall :   0
num_exists :   2
num_literals : 2
quantified form : exists NODE0,NODE1. has_lock(NODE0) | message(NODE0,NODE1)
qcost : 4



[QRM NOTE]: Time elapsed since start: 0.149 seconds

[QRM NOTE]: Time elapsed since last: 0.108 seconds

[QRM NOTE]: Peak memory: 1931788 bytes


==============================================================================================

	[MIN]: Minimization on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

==============================================================================================


New level: 1
 pending : []
 solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]


Before reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]

Essensial at level 1 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1)]

Covered at level 1 : set()

After reduction : 
 pending  : []
 solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]


Solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16] has cost 79.


Before backtrack at level 1
 pending : []
 solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]

After backtrack at level 1
 pending : []
 solution : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]


=============================================================================================================

	[MIN RESULT]: Minimized Invariants on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

=============================================================================================================

[MIN NOTE]: number of minimal solution found: 1

[MIN NOTE]: upper bound: 79

[MIN NOTE]: maximum branch and bound depth: 1

[MIN NOTE]: number of definitions: 0

[MIN NOTE]: number of equality relations: 0

[MIN NOTE]: Solution 0 : [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16]

[MIN NOTE]: solution length: 15

invariant [invar_1] forall NODE0,NODE1. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_2] forall NODE0,NODE1. ~message(NODE1,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_3] forall NODE0. ~message(NODE0,NODE0) | ~has_lock(NODE0) # qcost: 3

invariant [invar_4] forall NODE0,NODE2,NODE1. ~message(NODE0,NODE2) | ~message(NODE1,NODE1) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2) # qcost: 8

invariant [invar_5] forall NODE0,NODE1. ~message(NODE0,NODE1) | ~message(NODE1,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_6] forall NODE0,NODE1. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_7] forall NODE0,NODE1. ~has_lock(NODE1) | ~has_lock(NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_8] forall NODE0,NODE2,NODE1. ~message(NODE1,NODE2) | ~has_lock(NODE0) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2) # qcost: 8

invariant [invar_9] forall NODE0,NODE1. ~message(NODE1,NODE0) | ~has_lock(NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_10] forall NODE0,NODE1. ~message(NODE0,NODE1) | ~has_lock(NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_11] forall NODE1. (exists NODE0. (~message(NODE1,NODE0) & NODE0 ~= NODE1)) # qcost: 4

invariant [invar_12] forall NODE0,NODE2,NODE1. ~message(NODE1,NODE0) | ~message(NODE0,NODE2) | (NODE1 = NODE2 | NODE0 = NODE1 | NODE0 = NODE2) # qcost: 8

invariant [invar_13] forall NODE0,NODE1. ~message(NODE0,NODE1) | ~message(NODE1,NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_14] forall NODE1. (exists NODE0. (~message(NODE0,NODE1) & NODE0 ~= NODE1)) # qcost: 4

invariant [invar_16] exists NODE0,NODE1. has_lock(NODE0) | message(NODE0,NODE1) # qcost: 4

[MIN NOTE]: number of total invariants: 15

[MIN NOTE]: total qCost: 79




[QRM NOTE]: Time elapsed since start: 0.201 seconds

[QRM NOTE]: Time elapsed since last: 0.052 seconds

[QRM NOTE]: Peak memory: 1893708 bytes


**************************************************************************************************************

	[Reachability Convergence Check]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=3]

**************************************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy -s node=4 -f 2 -g -w -r -m -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


==============================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: node=4]

==============================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 24

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 24

[FW NOTE]: number of branching actions: 32

ivy_to_cpp target=qrm simple-decentralized-lock.node_4.finite.ivy

[IVY_TO_CPP RESULT]: OK

swig -c++ -python -o simple-decentralized-lock.node_4.finite_wrap.cpp ivy_exec.i

[SWIG RESULT]: OK

g++ -std=c++11 -fpic -pthread -O3 simple-decentralized-lock.node_4.finite.cpp simple-decentralized-lock.node_4.finite_wrap.cpp -I/home/yunrong/.pyenv/versions/3.12.0/include/python3.12 -c

[G++ RESULT]: OK

g++ -shared simple-decentralized-lock.node_4.finite.o simple-decentralized-lock.node_4.finite_wrap.o -o _ivy_exec.so -lm -lstdc++

[LINK RESULT]: OK

[QRM NOTE]: Time elapsed since start: 6.270 seconds

[QRM NOTE]: Time elapsed since last: 6.270 seconds

[QRM NOTE]: Peak memory: 1183550 bytes


===================================

	Forward reachability

===================================

[FW NOTE]: dfs max depth: 3

[FW NOTE]: number of total reachable states:        80

[FW NOTE]: number of dfs representative states:     7

[FW NOTE]: number of dfs non-representative states: 73


=====================================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: node=4]

=====================================================================================================================

sort: node=['node0', 'node1', 'node2', 'node3']
predicate: message('node', 'node')
predicate: start_node=('node',)
predicate: has_lock('node',)
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'has_lock(node1)', 'has_lock(node2)', 'has_lock(node3)', 'message(node0,node0)', 'message(node0,node1)', 'message(node0,node2)', 'message(node0,node3)', 'message(node1,node0)', 'message(node1,node1)', 'message(node1,node2)', 'message(node1,node3)', 'message(node2,node0)', 'message(node2,node1)', 'message(node2,node2)', 'message(node2,node3)', 'message(node3,node0)', 'message(node3,node1)', 'message(node3,node2)', 'message(node3,node3)', '(start_node=node0)', '(start_node=node1)', '(start_node=node2)', '(start_node=node3)']
representative states : 1048577, 17, 33, 1048578, 34, 18, 36


=== State Orbit 0 =====================
size : 4
repr state: 100000000000000000001000
lex min decimal: 1048577
states:
100000000000000000001000
010000000000000000000100
001000000000000000000010
000100000000000000000001




=== State Orbit 1 =====================
size : 4
repr state: 000010000000000000001000
lex min decimal: 17
states:
000000000000000000010001
000000000000001000000010
000010000000000000001000
000000000100000000000100




=== State Orbit 2 =====================
size : 12
repr state: 000001000000000000001000
lex min decimal: 33
states:
000000000010000000000100
000000010000000000001000
000000000000000100000010
000000000000100000000010
000000000000000001000001
000000100000000000001000
000000000000010000000010
000000000001000000000100
000000000000000010000001
000001000000000000001000
000000001000000000000100
000000000000000000100001




=== State Orbit 3 =====================
size : 12
repr state: 010000000000000000001000
lex min decimal: 1048578
states:
000100000000000000001000
010000000000000000001000
100000000000000000000001
010000000000000000000010
000100000000000000000100
001000000000000000000100
010000000000000000000001
001000000000000000000001
000100000000000000000010
100000000000000000000100
100000000000000000000010
001000000000000000001000




=== State Orbit 4 =====================
size : 12
repr state: 000000001000000000001000
lex min decimal: 34
states:
000000000000000100000001
000000000000000001000100
000001000000000000000100
000000000000100000001000
000000000001000000000001
000000000000000010001000
000000000000000000100010
000000100000000000000010
000000001000000000001000
000000000010000000000010
000000000000010000000100
000000010000000000000001




=== State Orbit 5 =====================
size : 12
repr state: 000000000100000000001000
lex min decimal: 18
states:
000000000000001000000100
000010000000000000000010
000000000100000000000001
000000000000001000001000
000000000000000000011000
000000000000000000010100
000000000000000000010010
000010000000000000000001
000000000100000000001000
000010000000000000000100
000000000000001000000001
000000000100000000000010




=== State Orbit 6 =====================
size : 24
repr state: 000000000010000000001000
lex min decimal: 36
states:
000000000000000100001000
000000100000000000000001
000000000001000000001000
000000000000100000000100
000000000000000001001000
000000000010000000001000
000000001000000000000001
000000010000000000000010
000001000000000000000010
000000000000000100000100
000000000000010000001000
000000000000010000000001
000000000000000000101000
000001000000000000000001
000000000000000001000010
000000000010000000000001
000000100000000000000100
000000000001000000000010
000000010000000000000100
000000000000000010000010
000000000000000010000100
000000000000100000000001
000000001000000000000010
000000000000000000100100



[QRM NOTE]: Time elapsed since start: 6.397 seconds

[QRM NOTE]: Time elapsed since last: 0.127 seconds

[QRM NOTE]: Peak memory: 1239765 bytes


==========================================================================================================================================

	[REACH_CHECK]: Reachability Convergence Check for Rmin on [ivybench/sym/ivy/simple-decentralized-lock.node_3.0.ivy: node=4]

==========================================================================================================================================

Found a representative state in Rmin not in reachability: decimal: 98, binary: 000000000000000001100010

Found a representative state in Rmin not in reachability: decimal: 1092, binary: 000000000000010001000100

Found a representative state in Rmin not in reachability: decimal: 1089, binary: 000000000000010001000001

Found a representative state in Rmin not in reachability: decimal: 97, binary: 000000000000000001100001

Found a representative state in Rmin not in reachability: decimal: 1153, binary: 000000000000010010000001

Found a representative state in Rmin not in reachability: decimal: 1217, binary: 000000000000010011000001

Found a representative state in Rmin not in reachability: decimal: 1096, binary: 000000000000010001001000

Found a representative state in Rmin not in reachability: decimal: 1156, binary: 000000000000010010000100

Found a representative state in Rmin not in reachability: decimal: 1224, binary: 000000000000010011001000

Found a representative state in Rmin not in reachability: decimal: 104, binary: 000000000000000001101000

Found a representative state in Rmin not in reachability: decimal: 1218, binary: 000000000000010011000010

Found a representative state in Rmin not in reachability: decimal: 3265, binary: 000000000000110011000001

Found a representative state in Rmin not in reachability: decimal: 3268, binary: 000000000000110011000100

Found a representative state in Rmin not in reachability: decimal: 1220, binary: 000000000000010011000100

[REACH_CHECK RESULT]: FAIL

[QRM NOTE]: Time elapsed since start: 6.833 seconds

[QRM NOTE]: Time elapsed since last: 0.436 seconds

[QRM NOTE]: Peak memory: 434777 bytes

next size: node=4


***********************************************************************************************

	[Synthesize Rmin]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

***********************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.ivy -s node=4 -f 1 -g -w -r -m -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


---------- Initializing reachability from file ----------

OK


======================================

	Reduce Equivalent Atoms

======================================

[FW NOTE]: equivalent atoms

[FW NOTE]: complement atoms

[FW NOTE]: remove_atom_ids: set()

[QRM NOTE]: Time elapsed since start: 0.030 seconds

[QRM NOTE]: Time elapsed since last: 0.030 seconds

[QRM NOTE]: Peak memory: 31100 bytes


============================================================================================================

	[PRIME]: Prime Orbit Generatation on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

============================================================================================================


=======================================================================================================

	[PRIME RESULT]: Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

=======================================================================================================


=== Prime Orbit 0 =====================
size : 24
num_suborbits: 1
0 (*) : ---------------1-1------
0     : ['message(node2,node3)', 'message(node3,node1)']
1     : -------------1----1-----
1     : ['message(node2,node1)', 'message(node3,node2)']
2     : -----------1------1-----
2     : ['message(node1,node3)', 'message(node3,node2)']
3     : ----------1------1------
3     : ['message(node1,node2)', 'message(node3,node1)']
4     : ----------1----1--------
4     : ['message(node1,node2)', 'message(node2,node3)']
5     : -----------1-1----------
5     : ['message(node1,node3)', 'message(node2,node1)']
6     : ---------------11-------
6     : ['message(node2,node3)', 'message(node3,node0)']
7     : ------------1-----1-----
7     : ['message(node2,node0)', 'message(node3,node2)']
8     : -------1----------1-----
8     : ['message(node0,node3)', 'message(node3,node2)']
9     : ------1---------1-------
9     : ['message(node0,node2)', 'message(node3,node0)']
10     : ------1--------1--------
10     : ['message(node0,node2)', 'message(node2,node3)']
11     : -------1----1-----------
11     : ['message(node0,node3)', 'message(node2,node0)']
12     : -----------1----1-------
12     : ['message(node1,node3)', 'message(node3,node0)']
13     : --------1--------1------
13     : ['message(node1,node0)', 'message(node3,node1)']
14     : -------1---------1------
14     : ['message(node0,node3)', 'message(node3,node1)']
15     : -----1----------1-------
15     : ['message(node0,node1)', 'message(node3,node0)']
16     : -----1-----1------------
16     : ['message(node0,node1)', 'message(node1,node3)']
17     : -------11---------------
17     : ['message(node0,node3)', 'message(node1,node0)']
18     : ----------1-1-----------
18     : ['message(node1,node2)', 'message(node2,node0)']
19     : --------1----1----------
19     : ['message(node1,node0)', 'message(node2,node1)']
20     : ------1------1----------
20     : ['message(node0,node2)', 'message(node2,node1)']
21     : -----1------1-----------
21     : ['message(node0,node1)', 'message(node2,node0)']
22     : -----1----1-------------
22     : ['message(node0,node1)', 'message(node1,node2)']
23     : ------1-1---------------
23     : ['message(node0,node2)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 1 =====================
size : 24
num_suborbits: 1
24 (*) : 1--------------1--------
24     : ['has_lock(node0)', 'message(node2,node3)']
25     : 1-----------------1-----
25     : ['has_lock(node0)', 'message(node3,node2)']
26     : 1----------1------------
26     : ['has_lock(node0)', 'message(node1,node3)']
27     : 1----------------1------
27     : ['has_lock(node0)', 'message(node3,node1)']
28     : 1---------1-------------
28     : ['has_lock(node0)', 'message(node1,node2)']
29     : 1------------1----------
29     : ['has_lock(node0)', 'message(node2,node1)']
30     : -1-------------1--------
30     : ['has_lock(node1)', 'message(node2,node3)']
31     : -1----------------1-----
31     : ['has_lock(node1)', 'message(node3,node2)']
32     : -1-----1----------------
32     : ['has_lock(node1)', 'message(node0,node3)']
33     : -1--------------1-------
33     : ['has_lock(node1)', 'message(node3,node0)']
34     : -1----1-----------------
34     : ['has_lock(node1)', 'message(node0,node2)']
35     : -1----------1-----------
35     : ['has_lock(node1)', 'message(node2,node0)']
36     : --1--------1------------
36     : ['has_lock(node2)', 'message(node1,node3)']
37     : --1--------------1------
37     : ['has_lock(node2)', 'message(node3,node1)']
38     : --1----1----------------
38     : ['has_lock(node2)', 'message(node0,node3)']
39     : --1-------------1-------
39     : ['has_lock(node2)', 'message(node3,node0)']
40     : --1--1------------------
40     : ['has_lock(node2)', 'message(node0,node1)']
41     : --1-----1---------------
41     : ['has_lock(node2)', 'message(node1,node0)']
42     : ---1------1-------------
42     : ['has_lock(node3)', 'message(node1,node2)']
43     : ---1---------1----------
43     : ['has_lock(node3)', 'message(node2,node1)']
44     : ---1--1-----------------
44     : ['has_lock(node3)', 'message(node0,node2)']
45     : ---1--------1-----------
45     : ['has_lock(node3)', 'message(node2,node0)']
46     : ---1-1------------------
46     : ['has_lock(node3)', 'message(node0,node1)']
47     : ---1----1---------------
47     : ['has_lock(node3)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 2 =====================
size : 12
num_suborbits: 1
48 (*) : --1------------1--------
48     : ['has_lock(node2)', 'message(node2,node3)']
49     : ---1--------------1-----
49     : ['has_lock(node3)', 'message(node3,node2)']
50     : -1---------1------------
50     : ['has_lock(node1)', 'message(node1,node3)']
51     : ---1-------------1------
51     : ['has_lock(node3)', 'message(node3,node1)']
52     : -1--------1-------------
52     : ['has_lock(node1)', 'message(node1,node2)']
53     : --1----------1----------
53     : ['has_lock(node2)', 'message(node2,node1)']
54     : 1------1----------------
54     : ['has_lock(node0)', 'message(node0,node3)']
55     : ---1------------1-------
55     : ['has_lock(node3)', 'message(node3,node0)']
56     : 1-----1-----------------
56     : ['has_lock(node0)', 'message(node0,node2)']
57     : --1---------1-----------
57     : ['has_lock(node2)', 'message(node2,node0)']
58     : 1----1------------------
58     : ['has_lock(node0)', 'message(node0,node1)']
59     : -1------1---------------
59     : ['has_lock(node1)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 3 =====================
size : 12
num_suborbits: 1
60 (*) : ---1-----------1--------
60     : ['has_lock(node3)', 'message(node2,node3)']
61     : --1---------------1-----
61     : ['has_lock(node2)', 'message(node3,node2)']
62     : ---1-------1------------
62     : ['has_lock(node3)', 'message(node1,node3)']
63     : -1---------------1------
63     : ['has_lock(node1)', 'message(node3,node1)']
64     : --1-------1-------------
64     : ['has_lock(node2)', 'message(node1,node2)']
65     : -1-----------1----------
65     : ['has_lock(node1)', 'message(node2,node1)']
66     : ---1---1----------------
66     : ['has_lock(node3)', 'message(node0,node3)']
67     : 1---------------1-------
67     : ['has_lock(node0)', 'message(node3,node0)']
68     : --1---1-----------------
68     : ['has_lock(node2)', 'message(node0,node2)']
69     : 1-----------1-----------
69     : ['has_lock(node0)', 'message(node2,node0)']
70     : -1---1------------------
70     : ['has_lock(node1)', 'message(node0,node1)']
71     : 1-------1---------------
71     : ['has_lock(node0)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 4 =====================
size : 24
num_suborbits: 1
72 (*) : ----1----------1--------
72     : ['message(node0,node0)', 'message(node2,node3)']
73     : ----1-------------1-----
73     : ['message(node0,node0)', 'message(node3,node2)']
74     : ----1------1------------
74     : ['message(node0,node0)', 'message(node1,node3)']
75     : ----1------------1------
75     : ['message(node0,node0)', 'message(node3,node1)']
76     : ----1-----1-------------
76     : ['message(node0,node0)', 'message(node1,node2)']
77     : ----1--------1----------
77     : ['message(node0,node0)', 'message(node2,node1)']
78     : ---------1-----1--------
78     : ['message(node1,node1)', 'message(node2,node3)']
79     : ---------1--------1-----
79     : ['message(node1,node1)', 'message(node3,node2)']
80     : -------1-1--------------
80     : ['message(node0,node3)', 'message(node1,node1)']
81     : ---------1------1-------
81     : ['message(node1,node1)', 'message(node3,node0)']
82     : ------1--1--------------
82     : ['message(node0,node2)', 'message(node1,node1)']
83     : ---------1--1-----------
83     : ['message(node1,node1)', 'message(node2,node0)']
84     : -----------1--1---------
84     : ['message(node1,node3)', 'message(node2,node2)']
85     : --------------1--1------
85     : ['message(node2,node2)', 'message(node3,node1)']
86     : -------1------1---------
86     : ['message(node0,node3)', 'message(node2,node2)']
87     : --------------1-1-------
87     : ['message(node2,node2)', 'message(node3,node0)']
88     : -----1--------1---------
88     : ['message(node0,node1)', 'message(node2,node2)']
89     : --------1-----1---------
89     : ['message(node1,node0)', 'message(node2,node2)']
90     : ----------1--------1----
90     : ['message(node1,node2)', 'message(node3,node3)']
91     : -------------1-----1----
91     : ['message(node2,node1)', 'message(node3,node3)']
92     : ------1------------1----
92     : ['message(node0,node2)', 'message(node3,node3)']
93     : ------------1------1----
93     : ['message(node2,node0)', 'message(node3,node3)']
94     : -----1-------------1----
94     : ['message(node0,node1)', 'message(node3,node3)']
95     : --------1----------1----
95     : ['message(node1,node0)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 5 =====================
size : 12
num_suborbits: 1
96 (*) : -----1---------1--------
96     : ['message(node0,node1)', 'message(node2,node3)']
97     : -----1------------1-----
97     : ['message(node0,node1)', 'message(node3,node2)']
98     : ------1----1------------
98     : ['message(node0,node2)', 'message(node1,node3)']
99     : ------1----------1------
99     : ['message(node0,node2)', 'message(node3,node1)']
100     : -------1--1-------------
100     : ['message(node0,node3)', 'message(node1,node2)']
101     : -------1-----1----------
101     : ['message(node0,node3)', 'message(node2,node1)']
102     : --------1------1--------
102     : ['message(node1,node0)', 'message(node2,node3)']
103     : --------1---------1-----
103     : ['message(node1,node0)', 'message(node3,node2)']
104     : ----------1-----1-------
104     : ['message(node1,node2)', 'message(node3,node0)']
105     : -----------11-----------
105     : ['message(node1,node3)', 'message(node2,node0)']
106     : ------------1----1------
106     : ['message(node2,node0)', 'message(node3,node1)']
107     : -------------1--1-------
107     : ['message(node2,node1)', 'message(node3,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 6 =====================
size : 12
num_suborbits: 1
108 (*) : -------1-------1--------
108     : ['message(node0,node3)', 'message(node2,node3)']
109     : ------1-----------1-----
109     : ['message(node0,node2)', 'message(node3,node2)']
110     : -------1---1------------
110     : ['message(node0,node3)', 'message(node1,node3)']
111     : -----1-----------1------
111     : ['message(node0,node1)', 'message(node3,node1)']
112     : ------1---1-------------
112     : ['message(node0,node2)', 'message(node1,node2)']
113     : -----1-------1----------
113     : ['message(node0,node1)', 'message(node2,node1)']
114     : -----------1---1--------
114     : ['message(node1,node3)', 'message(node2,node3)']
115     : ----------1-------1-----
115     : ['message(node1,node2)', 'message(node3,node2)']
116     : --------1-------1-------
116     : ['message(node1,node0)', 'message(node3,node0)']
117     : --------1---1-----------
117     : ['message(node1,node0)', 'message(node2,node0)']
118     : -------------1---1------
118     : ['message(node2,node1)', 'message(node3,node1)']
119     : ------------1---1-------
119     : ['message(node2,node0)', 'message(node3,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 7 =====================
size : 12
num_suborbits: 1
120 (*) : ------------1--1--------
120     : ['message(node2,node0)', 'message(node2,node3)']
121     : ----------------1-1-----
121     : ['message(node3,node0)', 'message(node3,node2)']
122     : --------1--1------------
122     : ['message(node1,node0)', 'message(node1,node3)']
123     : ----------------11------
123     : ['message(node3,node0)', 'message(node3,node1)']
124     : --------1-1-------------
124     : ['message(node1,node0)', 'message(node1,node2)']
125     : ------------11----------
125     : ['message(node2,node0)', 'message(node2,node1)']
126     : -------------1-1--------
126     : ['message(node2,node1)', 'message(node2,node3)']
127     : -----------------11-----
127     : ['message(node3,node1)', 'message(node3,node2)']
128     : -----1-1----------------
128     : ['message(node0,node1)', 'message(node0,node3)']
129     : -----11-----------------
129     : ['message(node0,node1)', 'message(node0,node2)']
130     : ----------11------------
130     : ['message(node1,node2)', 'message(node1,node3)']
131     : ------11----------------
131     : ['message(node0,node2)', 'message(node0,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 8 =====================
size : 12
num_suborbits: 1
132 (*) : --------------11--------
132     : ['message(node2,node2)', 'message(node2,node3)']
133     : ------------------11----
133     : ['message(node3,node2)', 'message(node3,node3)']
134     : ---------1-1------------
134     : ['message(node1,node1)', 'message(node1,node3)']
135     : -----------------1-1----
135     : ['message(node3,node1)', 'message(node3,node3)']
136     : ---------11-------------
136     : ['message(node1,node1)', 'message(node1,node2)']
137     : -------------11---------
137     : ['message(node2,node1)', 'message(node2,node2)']
138     : ----1--1----------------
138     : ['message(node0,node0)', 'message(node0,node3)']
139     : ----------------1--1----
139     : ['message(node3,node0)', 'message(node3,node3)']
140     : ----1-1-----------------
140     : ['message(node0,node0)', 'message(node0,node2)']
141     : ------------1-1---------
141     : ['message(node2,node0)', 'message(node2,node2)']
142     : ----11------------------
142     : ['message(node0,node0)', 'message(node0,node1)']
143     : --------11--------------
143     : ['message(node1,node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 9 =====================
size : 6
num_suborbits: 1
144 (*) : --------------------11--
144     : ['(start_node=node0)', '(start_node=node1)']
145     : --------------------1-1-
145     : ['(start_node=node0)', '(start_node=node2)']
146     : --------------------1--1
146     : ['(start_node=node0)', '(start_node=node3)']
147     : ---------------------11-
147     : ['(start_node=node1)', '(start_node=node2)']
148     : ---------------------1-1
148     : ['(start_node=node1)', '(start_node=node3)']
149     : ----------------------11
149     : ['(start_node=node2)', '(start_node=node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 10 =====================
size : 6
num_suborbits: 1
150 (*) : 11----------------------
150     : ['has_lock(node0)', 'has_lock(node1)']
151     : 1-1---------------------
151     : ['has_lock(node0)', 'has_lock(node2)']
152     : 1--1--------------------
152     : ['has_lock(node0)', 'has_lock(node3)']
153     : -11---------------------
153     : ['has_lock(node1)', 'has_lock(node2)']
154     : -1-1--------------------
154     : ['has_lock(node1)', 'has_lock(node3)']
155     : --11--------------------
155     : ['has_lock(node2)', 'has_lock(node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 11 =====================
size : 12
num_suborbits: 1
156 (*) : ---11-------------------
156     : ['has_lock(node3)', 'message(node0,node0)']
157     : --1-1-------------------
157     : ['has_lock(node2)', 'message(node0,node0)']
158     : -1--1-------------------
158     : ['has_lock(node1)', 'message(node0,node0)']
159     : ---1-----1--------------
159     : ['has_lock(node3)', 'message(node1,node1)']
160     : --1------1--------------
160     : ['has_lock(node2)', 'message(node1,node1)']
161     : 1--------1--------------
161     : ['has_lock(node0)', 'message(node1,node1)']
162     : ---1----------1---------
162     : ['has_lock(node3)', 'message(node2,node2)']
163     : -1------------1---------
163     : ['has_lock(node1)', 'message(node2,node2)']
164     : 1-------------1---------
164     : ['has_lock(node0)', 'message(node2,node2)']
165     : --1----------------1----
165     : ['has_lock(node2)', 'message(node3,node3)']
166     : -1-----------------1----
166     : ['has_lock(node1)', 'message(node3,node3)']
167     : 1------------------1----
167     : ['has_lock(node0)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 12 =====================
size : 4
num_suborbits: 1
168 (*) : 1---1-------------------
168     : ['has_lock(node0)', 'message(node0,node0)']
169     : -1-------1--------------
169     : ['has_lock(node1)', 'message(node1,node1)']
170     : --1-----------1---------
170     : ['has_lock(node2)', 'message(node2,node2)']
171     : ---1---------------1----
171     : ['has_lock(node3)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 13 =====================
size : 12
num_suborbits: 1
172 (*) : ----1---1---------------
172     : ['message(node0,node0)', 'message(node1,node0)']
173     : ----1-------1-----------
173     : ['message(node0,node0)', 'message(node2,node0)']
174     : ----1-----------1-------
174     : ['message(node0,node0)', 'message(node3,node0)']
175     : -----1---1--------------
175     : ['message(node0,node1)', 'message(node1,node1)']
176     : ---------1---1----------
176     : ['message(node1,node1)', 'message(node2,node1)']
177     : ---------1-------1------
177     : ['message(node1,node1)', 'message(node3,node1)']
178     : ------1-------1---------
178     : ['message(node0,node2)', 'message(node2,node2)']
179     : ----------1---1---------
179     : ['message(node1,node2)', 'message(node2,node2)']
180     : --------------1---1-----
180     : ['message(node2,node2)', 'message(node3,node2)']
181     : -------1-----------1----
181     : ['message(node0,node3)', 'message(node3,node3)']
182     : -----------1-------1----
182     : ['message(node1,node3)', 'message(node3,node3)']
183     : ---------------1---1----
183     : ['message(node2,node3)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 14 =====================
size : 6
num_suborbits: 1
184 (*) : -----1--1---------------
184     : ['message(node0,node1)', 'message(node1,node0)']
185     : ------1-----1-----------
185     : ['message(node0,node2)', 'message(node2,node0)']
186     : -------1--------1-------
186     : ['message(node0,node3)', 'message(node3,node0)']
187     : ----------1--1----------
187     : ['message(node1,node2)', 'message(node2,node1)']
188     : -----------1-----1------
188     : ['message(node1,node3)', 'message(node3,node1)']
189     : ---------------1--1-----
189     : ['message(node2,node3)', 'message(node3,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 15 =====================
size : 6
num_suborbits: 1
190 (*) : ----1----1--------------
190     : ['message(node0,node0)', 'message(node1,node1)']
191     : ----1---------1---------
191     : ['message(node0,node0)', 'message(node2,node2)']
192     : ----1--------------1----
192     : ['message(node0,node0)', 'message(node3,node3)']
193     : ---------1----1---------
193     : ['message(node1,node1)', 'message(node2,node2)']
194     : ---------1---------1----
194     : ['message(node1,node1)', 'message(node3,node3)']
195     : --------------1----1----
195     : ['message(node2,node2)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 16 =====================
size : 1
num_suborbits: 1
196 (*) : --------------------0000
196     : ['~(start_node=node0)', '~(start_node=node1)', '~(start_node=node2)', '~(start_node=node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0


=== Prime Orbit 17 =====================
size : 1
num_suborbits: 1
197 (*) : 00000000000000000000----
197     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~has_lock(node3)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node0,node3)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node1,node3)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)', '~message(node2,node3)', '~message(node3,node0)', '~message(node3,node1)', '~message(node3,node2)', '~message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0



[PRIME NOTE]: number of orbits after merging: 18

[PRIME NOTE]: number of orbits before merging: 18

[PRIME NOTE]: number of primes: 198

[QRM NOTE]: Time elapsed since start: 0.109 seconds

[QRM NOTE]: Time elapsed since last: 0.079 seconds

[QRM NOTE]: Peak memory: 1400819 bytes


=================================================================================================

	[RED]: PRIME REDUCTION on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

=================================================================================================

definition primes: {16, 9}


New level: 0
 pending : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]
 solution : []


Before reduction : 
 pending  : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]
 solution : []

Essensial at level 0 : {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17}

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1), (17, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1), (17, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]


Before reduction : 
 pending  : []
 solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]

Essensial at level 0 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1), (17, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1), (17, -1)]

Covered at level 0 : set()

After reduction : 
 pending  : []
 solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]

[QRM NOTE]: Time elapsed since start: 0.116 seconds

[QRM NOTE]: Time elapsed since last: 0.006 seconds

[QRM NOTE]: Peak memory: 352102 bytes


=====================================================================================================

	[QI]: Quantifier Inference on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

=====================================================================================================


---------- quantifier_inference ----------


=== Prime Orbit 0 =====================
size : 24
num_suborbits: 1
0 (*) : ---------------1-1------
0     : ['message(node2,node3)', 'message(node3,node1)']
1     : -------------1----1-----
1     : ['message(node2,node1)', 'message(node3,node2)']
2     : -----------1------1-----
2     : ['message(node1,node3)', 'message(node3,node2)']
3     : ----------1------1------
3     : ['message(node1,node2)', 'message(node3,node1)']
4     : ----------1----1--------
4     : ['message(node1,node2)', 'message(node2,node3)']
5     : -----------1-1----------
5     : ['message(node1,node3)', 'message(node2,node1)']
6     : ---------------11-------
6     : ['message(node2,node3)', 'message(node3,node0)']
7     : ------------1-----1-----
7     : ['message(node2,node0)', 'message(node3,node2)']
8     : -------1----------1-----
8     : ['message(node0,node3)', 'message(node3,node2)']
9     : ------1---------1-------
9     : ['message(node0,node2)', 'message(node3,node0)']
10     : ------1--------1--------
10     : ['message(node0,node2)', 'message(node2,node3)']
11     : -------1----1-----------
11     : ['message(node0,node3)', 'message(node2,node0)']
12     : -----------1----1-------
12     : ['message(node1,node3)', 'message(node3,node0)']
13     : --------1--------1------
13     : ['message(node1,node0)', 'message(node3,node1)']
14     : -------1---------1------
14     : ['message(node0,node3)', 'message(node3,node1)']
15     : -----1----------1-------
15     : ['message(node0,node1)', 'message(node3,node0)']
16     : -----1-----1------------
16     : ['message(node0,node1)', 'message(node1,node3)']
17     : -------11---------------
17     : ['message(node0,node3)', 'message(node1,node0)']
18     : ----------1-1-----------
18     : ['message(node1,node2)', 'message(node2,node0)']
19     : --------1----1----------
19     : ['message(node1,node0)', 'message(node2,node1)']
20     : ------1------1----------
20     : ['message(node0,node2)', 'message(node2,node1)']
21     : -----1------1-----------
21     : ['message(node0,node1)', 'message(node2,node0)']
22     : -----1----1-------------
22     : ['message(node0,node1)', 'message(node1,node2)']
23     : ------1-1---------------
23     : ['message(node0,node2)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node2,node3)', 'message(node3,node1)']

sign_func_name2args: {'0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$0, node$0$message$0$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0, node$0$message$0$1; node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0 | node$0$message$0$1; node$0$message$1$0 | node$0$message$1$1}

part_sig: ('node$0$message$0$0 | node$0$message$0$1; node$0$message$1$0 | node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node2,node3)', 'message(node3,node1)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0, node$0$message$0$1; node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0 | node$0$message$0$1; node$0$message$1$0 | node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0': [node$0$message$0$0], 'node$0$message$0; node$0$message$1': [node$0$message$0$1; node$0$message$1$0], 'node$0$message$1': [node$0$message$1$1]}

	identical_single_classes: {'node$0$message$0': node$0$message$0$0, 'node$0$message$0; node$0$message$1': node$0$message$0$1; node$0$message$1$0, 'node$0$message$1': node$0$message$1$1}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE2)', 'message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0,NODE2. ~message(NODE1,NODE2) | ~message(NODE0,NODE1) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)


=== Prime Orbit 1 =====================
size : 24
num_suborbits: 1
24 (*) : 1--------------1--------
24     : ['has_lock(node0)', 'message(node2,node3)']
25     : 1-----------------1-----
25     : ['has_lock(node0)', 'message(node3,node2)']
26     : 1----------1------------
26     : ['has_lock(node0)', 'message(node1,node3)']
27     : 1----------------1------
27     : ['has_lock(node0)', 'message(node3,node1)']
28     : 1---------1-------------
28     : ['has_lock(node0)', 'message(node1,node2)']
29     : 1------------1----------
29     : ['has_lock(node0)', 'message(node2,node1)']
30     : -1-------------1--------
30     : ['has_lock(node1)', 'message(node2,node3)']
31     : -1----------------1-----
31     : ['has_lock(node1)', 'message(node3,node2)']
32     : -1-----1----------------
32     : ['has_lock(node1)', 'message(node0,node3)']
33     : -1--------------1-------
33     : ['has_lock(node1)', 'message(node3,node0)']
34     : -1----1-----------------
34     : ['has_lock(node1)', 'message(node0,node2)']
35     : -1----------1-----------
35     : ['has_lock(node1)', 'message(node2,node0)']
36     : --1--------1------------
36     : ['has_lock(node2)', 'message(node1,node3)']
37     : --1--------------1------
37     : ['has_lock(node2)', 'message(node3,node1)']
38     : --1----1----------------
38     : ['has_lock(node2)', 'message(node0,node3)']
39     : --1-------------1-------
39     : ['has_lock(node2)', 'message(node3,node0)']
40     : --1--1------------------
40     : ['has_lock(node2)', 'message(node0,node1)']
41     : --1-----1---------------
41     : ['has_lock(node2)', 'message(node1,node0)']
42     : ---1------1-------------
42     : ['has_lock(node3)', 'message(node1,node2)']
43     : ---1---------1----------
43     : ['has_lock(node3)', 'message(node2,node1)']
44     : ---1--1-----------------
44     : ['has_lock(node3)', 'message(node0,node2)']
45     : ---1--------1-----------
45     : ['has_lock(node3)', 'message(node2,node0)']
46     : ---1-1------------------
46     : ['has_lock(node3)', 'message(node0,node1)']
47     : ---1----1---------------
47     : ['has_lock(node3)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node2,node3)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),)], '0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$has_lock$0$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node2,node3)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0 | node$0$message$0$0 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0], 'node$0$message$0': [node$0$message$0$0], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0': node$0$has_lock$0$0, 'node$0$message$0': node$0$message$0$0, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'message(NODE1,NODE2)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0,NODE2. ~has_lock(NODE0) | ~message(NODE1,NODE2) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)


=== Prime Orbit 2 =====================
size : 12
num_suborbits: 1
48 (*) : --1------------1--------
48     : ['has_lock(node2)', 'message(node2,node3)']
49     : ---1--------------1-----
49     : ['has_lock(node3)', 'message(node3,node2)']
50     : -1---------1------------
50     : ['has_lock(node1)', 'message(node1,node3)']
51     : ---1-------------1------
51     : ['has_lock(node3)', 'message(node3,node1)']
52     : -1--------1-------------
52     : ['has_lock(node1)', 'message(node1,node2)']
53     : --1----------1----------
53     : ['has_lock(node2)', 'message(node2,node1)']
54     : 1------1----------------
54     : ['has_lock(node0)', 'message(node0,node3)']
55     : ---1------------1-------
55     : ['has_lock(node3)', 'message(node3,node0)']
56     : 1-----1-----------------
56     : ['has_lock(node0)', 'message(node0,node2)']
57     : --1---------1-----------
57     : ['has_lock(node2)', 'message(node2,node0)']
58     : 1----1------------------
58     : ['has_lock(node0)', 'message(node0,node1)']
59     : -1------1---------------
59     : ['has_lock(node1)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node2)', 'message(node2,node3)']

sign_func_name2args: {'0$has_lock': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),)], '0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$has_lock$0$0, node$0$message$0$0], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0; node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node2)', 'message(node2,node3)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0; node$0$message$0$0, node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0; node$0$message$0$0 | node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$0': [node$0$has_lock$0$0; node$0$message$0$0], 'node$0$message$1': [node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$0': node$0$has_lock$0$0; node$0$message$0$0, 'node$0$message$1': node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]], '0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1


=== Prime Orbit 3 =====================
size : 12
num_suborbits: 1
60 (*) : ---1-----------1--------
60     : ['has_lock(node3)', 'message(node2,node3)']
61     : --1---------------1-----
61     : ['has_lock(node2)', 'message(node3,node2)']
62     : ---1-------1------------
62     : ['has_lock(node3)', 'message(node1,node3)']
63     : -1---------------1------
63     : ['has_lock(node1)', 'message(node3,node1)']
64     : --1-------1-------------
64     : ['has_lock(node2)', 'message(node1,node2)']
65     : -1-----------1----------
65     : ['has_lock(node1)', 'message(node2,node1)']
66     : ---1---1----------------
66     : ['has_lock(node3)', 'message(node0,node3)']
67     : 1---------------1-------
67     : ['has_lock(node0)', 'message(node3,node0)']
68     : --1---1-----------------
68     : ['has_lock(node2)', 'message(node0,node2)']
69     : 1-----------1-----------
69     : ['has_lock(node0)', 'message(node2,node0)']
70     : -1---1------------------
70     : ['has_lock(node1)', 'message(node0,node1)']
71     : 1-------1---------------
71     : ['has_lock(node0)', 'message(node1,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node3)', 'message(node2,node3)']

sign_func_name2args: {'0$has_lock': [(Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),)], '0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$has_lock$0$0, node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0]}

sig2const: {'node$0$has_lock$0$0': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0; node$0$message$1$0, node$0$message$0$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node3)', 'message(node2,node3)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0; node$0$message$1$0, node$0$message$0$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0; node$0$message$1$0 | node$0$message$0$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$1': [node$0$has_lock$0$0; node$0$message$1$0], 'node$0$message$0': [node$0$message$0$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$1': node$0$has_lock$0$0; node$0$message$1$0, 'node$0$message$0': node$0$message$0$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'message(NODE1,NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1


=== Prime Orbit 4 =====================
size : 24
num_suborbits: 1
72 (*) : ----1----------1--------
72     : ['message(node0,node0)', 'message(node2,node3)']
73     : ----1-------------1-----
73     : ['message(node0,node0)', 'message(node3,node2)']
74     : ----1------1------------
74     : ['message(node0,node0)', 'message(node1,node3)']
75     : ----1------------1------
75     : ['message(node0,node0)', 'message(node3,node1)']
76     : ----1-----1-------------
76     : ['message(node0,node0)', 'message(node1,node2)']
77     : ----1--------1----------
77     : ['message(node0,node0)', 'message(node2,node1)']
78     : ---------1-----1--------
78     : ['message(node1,node1)', 'message(node2,node3)']
79     : ---------1--------1-----
79     : ['message(node1,node1)', 'message(node3,node2)']
80     : -------1-1--------------
80     : ['message(node0,node3)', 'message(node1,node1)']
81     : ---------1------1-------
81     : ['message(node1,node1)', 'message(node3,node0)']
82     : ------1--1--------------
82     : ['message(node0,node2)', 'message(node1,node1)']
83     : ---------1--1-----------
83     : ['message(node1,node1)', 'message(node2,node0)']
84     : -----------1--1---------
84     : ['message(node1,node3)', 'message(node2,node2)']
85     : --------------1--1------
85     : ['message(node2,node2)', 'message(node3,node1)']
86     : -------1------1---------
86     : ['message(node0,node3)', 'message(node2,node2)']
87     : --------------1-1-------
87     : ['message(node2,node2)', 'message(node3,node0)']
88     : -----1--------1---------
88     : ['message(node0,node1)', 'message(node2,node2)']
89     : --------1-----1---------
89     : ['message(node1,node0)', 'message(node2,node2)']
90     : ----------1--------1----
90     : ['message(node1,node2)', 'message(node3,node3)']
91     : -------------1-----1----
91     : ['message(node2,node1)', 'message(node3,node3)']
92     : ------1------------1----
92     : ['message(node0,node2)', 'message(node3,node3)']
93     : ------------1------1----
93     : ['message(node2,node0)', 'message(node3,node3)']
94     : -----1-------------1----
94     : ['message(node0,node1)', 'message(node3,node3)']
95     : --------1----------1----
95     : ['message(node1,node0)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node0)', 'message(node2,node3)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0, node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$1], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1 | node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1 | node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node0)', 'message(node2,node3)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1 | node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$0], 'node$0$message$0': [node$0$message$0$1], 'node$0$message$1': [node$0$message$1$1]}

	identical_single_classes: {'node$0$message$0; node$0$message$1': node$0$message$0$0; node$0$message$1$0, 'node$0$message$0': node$0$message$0$1, 'node$0$message$1': node$0$message$1$1}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE2)', 'message(NODE0,NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0,NODE2. ~message(NODE1,NODE2) | ~message(NODE0,NODE0) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)


=== Prime Orbit 5 =====================
size : 12
num_suborbits: 1
96 (*) : -----1---------1--------
96     : ['message(node0,node1)', 'message(node2,node3)']
97     : -----1------------1-----
97     : ['message(node0,node1)', 'message(node3,node2)']
98     : ------1----1------------
98     : ['message(node0,node2)', 'message(node1,node3)']
99     : ------1----------1------
99     : ['message(node0,node2)', 'message(node3,node1)']
100     : -------1--1-------------
100     : ['message(node0,node3)', 'message(node1,node2)']
101     : -------1-----1----------
101     : ['message(node0,node3)', 'message(node2,node1)']
102     : --------1------1--------
102     : ['message(node1,node0)', 'message(node2,node3)']
103     : --------1---------1-----
103     : ['message(node1,node0)', 'message(node3,node2)']
104     : ----------1-----1-------
104     : ['message(node1,node2)', 'message(node3,node0)']
105     : -----------11-----------
105     : ['message(node1,node3)', 'message(node2,node0)']
106     : ------------1----1------
106     : ['message(node2,node0)', 'message(node3,node1)']
107     : -------------1--1-------
107     : ['message(node2,node1)', 'message(node3,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node2,node3)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$0], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$1], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

part_sig: ('node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node1)', 'message(node2,node3)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE2)', 'message(NODE1,NODE3)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE3,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE1,NODE3) | (NODE0 = NODE3 | NODE1 = NODE3 | NODE0 = NODE2 | NODE2 = NODE3 | NODE0 = NODE1 | NODE1 = NODE2)


=== Prime Orbit 6 =====================
size : 12
num_suborbits: 1
108 (*) : -------1-------1--------
108     : ['message(node0,node3)', 'message(node2,node3)']
109     : ------1-----------1-----
109     : ['message(node0,node2)', 'message(node3,node2)']
110     : -------1---1------------
110     : ['message(node0,node3)', 'message(node1,node3)']
111     : -----1-----------1------
111     : ['message(node0,node1)', 'message(node3,node1)']
112     : ------1---1-------------
112     : ['message(node0,node2)', 'message(node1,node2)']
113     : -----1-------1----------
113     : ['message(node0,node1)', 'message(node2,node1)']
114     : -----------1---1--------
114     : ['message(node1,node3)', 'message(node2,node3)']
115     : ----------1-------1-----
115     : ['message(node1,node2)', 'message(node3,node2)']
116     : --------1-------1-------
116     : ['message(node1,node0)', 'message(node3,node0)']
117     : --------1---1-----------
117     : ['message(node1,node0)', 'message(node2,node0)']
118     : -------------1---1------
118     : ['message(node2,node1)', 'message(node3,node1)']
119     : ------------1---1-------
119     : ['message(node2,node0)', 'message(node3,node0)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node3)', 'message(node2,node3)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$0, node$0$message$1$1], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0; node$0$message$1$1}

part_sig: ('node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0; node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node3)', 'message(node2,node3)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0, node$0$message$0$1, node$0$message$1$0; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0 | node$0$message$0$1 | node$0$message$1$0; node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1], 'node$0$message$1; node$0$message$1': [node$0$message$1$0; node$0$message$1$1]}

	identical_single_classes: {'node$0$message$1; node$0$message$1': node$0$message$1$0; node$0$message$1$1}

	identical_multi_classes: {'node$0$message$0': [node$0$message$0$0, node$0$message$0$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE2)', 'message(NODE1,NODE2)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE1,NODE2) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)


=== Prime Orbit 7 =====================
size : 12
num_suborbits: 1
120 (*) : ------------1--1--------
120     : ['message(node2,node0)', 'message(node2,node3)']
121     : ----------------1-1-----
121     : ['message(node3,node0)', 'message(node3,node2)']
122     : --------1--1------------
122     : ['message(node1,node0)', 'message(node1,node3)']
123     : ----------------11------
123     : ['message(node3,node0)', 'message(node3,node1)']
124     : --------1-1-------------
124     : ['message(node1,node0)', 'message(node1,node2)']
125     : ------------11----------
125     : ['message(node2,node0)', 'message(node2,node1)']
126     : -------------1-1--------
126     : ['message(node2,node1)', 'message(node2,node3)']
127     : -----------------11-----
127     : ['message(node3,node1)', 'message(node3,node2)']
128     : -----1-1----------------
128     : ['message(node0,node1)', 'message(node0,node3)']
129     : -----11-----------------
129     : ['message(node0,node1)', 'message(node0,node2)']
130     : ----------11------------
130     : ['message(node1,node2)', 'message(node1,node3)']
131     : ------11----------------
131     : ['message(node0,node2)', 'message(node0,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node2,node0)', 'message(node2,node3)']

sign_func_name2args: {'0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0, node$0$message$0$1], Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$0], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node2,node0)', 'message(node2,node3)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$0$1, node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$0$1 | node$0$message$1$0 | node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$0': [node$0$message$0$0; node$0$message$0$1], 'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}

	identical_single_classes: {'node$0$message$0; node$0$message$0': node$0$message$0$0; node$0$message$0$1}

	identical_multi_classes: {'node$0$message$1': [node$0$message$1$0, node$0$message$1$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE2)', 'message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE0,NODE1) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)


=== Prime Orbit 8 =====================
size : 12
num_suborbits: 1
132 (*) : --------------11--------
132     : ['message(node2,node2)', 'message(node2,node3)']
133     : ------------------11----
133     : ['message(node3,node2)', 'message(node3,node3)']
134     : ---------1-1------------
134     : ['message(node1,node1)', 'message(node1,node3)']
135     : -----------------1-1----
135     : ['message(node3,node1)', 'message(node3,node3)']
136     : ---------11-------------
136     : ['message(node1,node1)', 'message(node1,node2)']
137     : -------------11---------
137     : ['message(node2,node1)', 'message(node2,node2)']
138     : ----1--1----------------
138     : ['message(node0,node0)', 'message(node0,node3)']
139     : ----------------1--1----
139     : ['message(node3,node0)', 'message(node3,node3)']
140     : ----1-1-----------------
140     : ['message(node0,node0)', 'message(node0,node2)']
141     : ------------1-1---------
141     : ['message(node2,node0)', 'message(node2,node2)']
142     : ----11------------------
142     : ['message(node0,node0)', 'message(node0,node1)']
143     : --------11--------------
143     : ['message(node1,node0)', 'message(node1,node1)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node2,node2)', 'message(node2,node3)']

sign_func_name2args: {'0$message': [(Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0, node$0$message$1$0, node$0$message$0$1], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$0$1; node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$0$1; node$0$message$1$0 | node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$0$1; node$0$message$1$0 | node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node2,node2)', 'message(node2,node3)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$0$1; node$0$message$1$0, node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$0$1; node$0$message$1$0 | node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$0$1; node$0$message$1$0], 'node$0$message$1': [node$0$message$1$1]}

	identical_single_classes: {'node$0$message$0; node$0$message$0; node$0$message$1': node$0$message$0$0; node$0$message$0$1; node$0$message$1$0, 'node$0$message$1': node$0$message$1$1}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1


=== Prime Orbit 10 =====================
size : 6
num_suborbits: 1
150 (*) : 11----------------------
150     : ['has_lock(node0)', 'has_lock(node1)']
151     : 1-1---------------------
151     : ['has_lock(node0)', 'has_lock(node2)']
152     : 1--1--------------------
152     : ['has_lock(node0)', 'has_lock(node3)']
153     : -11---------------------
153     : ['has_lock(node1)', 'has_lock(node2)']
154     : -1-1--------------------
154     : ['has_lock(node1)', 'has_lock(node3)']
155     : --11--------------------
155     : ['has_lock(node2)', 'has_lock(node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'has_lock(node1)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),)]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$has_lock$0$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$has_lock$0$1]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

part_sig: ('node$0$has_lock$0$0 | node$0$has_lock$0$1',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'has_lock(node1)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')),)}

sign_func_name2count:  {'0$has_lock': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0, node$0$has_lock$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0 | node$0$has_lock$0$1}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0, node$0$has_lock$0$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'has_lock(NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~has_lock(NODE0) | ~has_lock(NODE1) | NODE0 = NODE1


=== Prime Orbit 11 =====================
size : 12
num_suborbits: 1
156 (*) : ---11-------------------
156     : ['has_lock(node3)', 'message(node0,node0)']
157     : --1-1-------------------
157     : ['has_lock(node2)', 'message(node0,node0)']
158     : -1--1-------------------
158     : ['has_lock(node1)', 'message(node0,node0)']
159     : ---1-----1--------------
159     : ['has_lock(node3)', 'message(node1,node1)']
160     : --1------1--------------
160     : ['has_lock(node2)', 'message(node1,node1)']
161     : 1--------1--------------
161     : ['has_lock(node0)', 'message(node1,node1)']
162     : ---1----------1---------
162     : ['has_lock(node3)', 'message(node2,node2)']
163     : -1------------1---------
163     : ['has_lock(node1)', 'message(node2,node2)']
164     : 1-------------1---------
164     : ['has_lock(node0)', 'message(node2,node2)']
165     : --1----------------1----
165     : ['has_lock(node2)', 'message(node3,node3)']
166     : -1-----------------1----
166     : ['has_lock(node1)', 'message(node3,node3)']
167     : 1------------------1----
167     : ['has_lock(node0)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node3)', 'message(node0,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$has_lock$0$0], Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0, node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node3)', 'message(node0,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0, node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0 | node$0$message$0$0; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0': [node$0$has_lock$0$0], 'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0': node$0$has_lock$0$0, 'node$0$message$0; node$0$message$1': node$0$message$0$0; node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]], '0$message': [[Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'message(NODE1,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1


=== Prime Orbit 12 =====================
size : 4
num_suborbits: 1
168 (*) : 1---1-------------------
168     : ['has_lock(node0)', 'message(node0,node0)']
169     : -1-------1--------------
169     : ['has_lock(node1)', 'message(node1,node1)']
170     : --1-----------1---------
170     : ['has_lock(node2)', 'message(node2,node2)']
171     : ---1---------------1----
171     : ['has_lock(node3)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['has_lock(node0)', 'message(node0,node0)']

sign_func_name2args: {'0$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),)], '0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$has_lock$0$0, node$0$message$0$0, node$0$message$1$0]}

sig2const: {'node$0$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

part_sig: ('node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['has_lock(node0)', 'message(node0,node0)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$has_lock': 1, '0$message': 1}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': [node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0]}

	identical_single_classes: {'node$0$has_lock$0; node$0$message$0; node$0$message$1': node$0$has_lock$0$0; node$0$message$0$0; node$0$message$1$0}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]], '0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['has_lock(NODE0)', 'message(NODE0,NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE0)


=== Prime Orbit 13 =====================
size : 12
num_suborbits: 1
172 (*) : ----1---1---------------
172     : ['message(node0,node0)', 'message(node1,node0)']
173     : ----1-------1-----------
173     : ['message(node0,node0)', 'message(node2,node0)']
174     : ----1-----------1-------
174     : ['message(node0,node0)', 'message(node3,node0)']
175     : -----1---1--------------
175     : ['message(node0,node1)', 'message(node1,node1)']
176     : ---------1---1----------
176     : ['message(node1,node1)', 'message(node2,node1)']
177     : ---------1-------1------
177     : ['message(node1,node1)', 'message(node3,node1)']
178     : ------1-------1---------
178     : ['message(node0,node2)', 'message(node2,node2)']
179     : ----------1---1---------
179     : ['message(node1,node2)', 'message(node2,node2)']
180     : --------------1---1-----
180     : ['message(node2,node2)', 'message(node3,node2)']
181     : -------1-----------1----
181     : ['message(node0,node3)', 'message(node3,node3)']
182     : -----------1-------1----
182     : ['message(node1,node3)', 'message(node3,node3)']
183     : ---------------1---1----
183     : ['message(node2,node3)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node0)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0, node$0$message$1$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$1$0; node$0$message$1$1, node$0$message$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$1$0; node$0$message$1$1 | node$0$message$0$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0; node$0$message$1$1 | node$0$message$0$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node0)', 'message(node1,node0)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$1$0; node$0$message$1$1, node$0$message$0$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$1$0; node$0$message$1$1 | node$0$message$0$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1; node$0$message$1': [node$0$message$0$0; node$0$message$1$0; node$0$message$1$1], 'node$0$message$0': [node$0$message$0$1]}

	identical_single_classes: {'node$0$message$0; node$0$message$1; node$0$message$1': node$0$message$0$0; node$0$message$1$0; node$0$message$1$1, 'node$0$message$0': node$0$message$0$1}

	identical_multi_classes: {}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'message(NODE1,NODE0)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1


=== Prime Orbit 14 =====================
size : 6
num_suborbits: 1
184 (*) : -----1--1---------------
184     : ['message(node0,node1)', 'message(node1,node0)']
185     : ------1-----1-----------
185     : ['message(node0,node2)', 'message(node2,node0)']
186     : -------1--------1-------
186     : ['message(node0,node3)', 'message(node3,node0)']
187     : ----------1--1----------
187     : ['message(node1,node2)', 'message(node2,node1)']
188     : -----------1-----1------
188     : ['message(node1,node3)', 'message(node3,node1)']
189     : ---------------1--1-----
189     : ['message(node2,node3)', 'message(node3,node2)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node1)', 'message(node1,node0)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0, node$0$message$1$1], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$1$0, node$0$message$0$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0}

part_sig: ('node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0',)


---------- SigGenerator ----------

terms:  ['message(node0,node1)', 'message(node1,node0)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$1$1 | node$0$message$0$1; node$0$message$1$0}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$1, node$0$message$0$1; node$0$message$1$0]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0, node$0$message$1$1, node$0$message$0$1, node$0$message$1$0]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE1,NODE0)', 'message(NODE0,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE1,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1


=== Prime Orbit 15 =====================
size : 6
num_suborbits: 1
190 (*) : ----1----1--------------
190     : ['message(node0,node0)', 'message(node1,node1)']
191     : ----1---------1---------
191     : ['message(node0,node0)', 'message(node2,node2)']
192     : ----1--------------1----
192     : ['message(node0,node0)', 'message(node3,node3)']
193     : ---------1----1---------
193     : ['message(node1,node1)', 'message(node2,node2)']
194     : ---------1---------1----
194     : ['message(node1,node1)', 'message(node3,node3)']
195     : --------------1----1----
195     : ['message(node2,node2)', 'message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['message(node0,node0)', 'message(node1,node1)']

sign_func_name2args: {'0$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$0, node$0$message$1$0], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$0$message$0$1, node$0$message$1$1]}

sig2const: {'node$0$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$0$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1}

part_sig: ('node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1',)


---------- SigGenerator ----------

terms:  ['message(node0,node0)', 'message(node1,node1)']

func_name2symbol:  {'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'0$message': 2}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$0$message$0$0; node$0$message$1$0 | node$0$message$0$1; node$0$message$1$1}

	sort: node

	identical_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0; node$0$message$1$0, node$0$message$0$1; node$0$message$1$1]}

	identical_single_classes: {}

	identical_multi_classes: {'node$0$message$0; node$0$message$1': [node$0$message$0$0, node$0$message$1$0, node$0$message$0$1, node$0$message$1$1]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.forall


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

exists_qvars: set()


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'0$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['message(NODE0,NODE0)', 'message(NODE1,NODE1)']


---------- QFormula: get_qclause ----------

qclause: forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1


=== Prime Orbit 17 =====================
size : 1
num_suborbits: 1
197 (*) : 00000000000000000000----
197     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~has_lock(node3)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node0,node3)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node1,node3)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)', '~message(node2,node3)', '~message(node3,node0)', '~message(node3,node1)', '~message(node3,node2)', '~message(node3,node3)']
num_forall :   0
num_exists :   0
num_literals : 0
quantified form : None
qcost : 0




---------- QPrime ----------


---------- ConstArgBinding ----------

terms: ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~has_lock(node3)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node0,node3)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node1,node3)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)', '~message(node2,node3)', '~message(node3,node0)', '~message(node3,node1)', '~message(node3,node2)', '~message(node3,node3)']

sign_func_name2args: {'1$has_lock': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),), (Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))),)], '1$message': [(Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))), (Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))))]}

const2sigs: {Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$1$0, node$1$message$0$1, node$1$message$0$2, node$1$message$0$3, node$1$message$1$4, node$1$message$1$8, node$1$message$1$12], Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$1$has_lock$0$1, node$1$message$1$1, node$1$message$0$4, node$1$message$0$5, node$1$message$1$5, node$1$message$0$6, node$1$message$0$7, node$1$message$1$9, node$1$message$1$13], Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$1$has_lock$0$2, node$1$message$1$2, node$1$message$1$6, node$1$message$0$8, node$1$message$0$9, node$1$message$0$10, node$1$message$1$10, node$1$message$0$11, node$1$message$1$14], Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))): [node$1$has_lock$0$3, node$1$message$1$3, node$1$message$1$7, node$1$message$1$11, node$1$message$0$12, node$1$message$0$13, node$1$message$0$14, node$1$message$0$15, node$1$message$1$15]}

sig2const: {'node$1$has_lock$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$has_lock$0$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$has_lock$0$2': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$has_lock$0$3': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$0': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$1': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$1': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$2': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$2': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$3': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$3': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$4': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$4': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$5': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$5': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$6': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$6': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$7': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$7': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$8': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$8': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$9': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$9': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$10': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$10': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$11': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$11': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$12': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$12': Const('node0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$13': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$13': Const('node1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$14': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$14': Const('node2', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$0$15': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), 'node$1$message$1$15': Const('node3', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- ArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$0; node$1$message$1$12; node$1$message$1$4; node$1$message$1$8, node$1$has_lock$0$1; node$1$message$0$4; node$1$message$0$5; node$1$message$0$6; node$1$message$0$7; node$1$message$1$1; node$1$message$1$13; node$1$message$1$5; node$1$message$1$9, node$1$has_lock$0$2; node$1$message$0$10; node$1$message$0$11; node$1$message$0$8; node$1$message$0$9; node$1$message$1$10; node$1$message$1$14; node$1$message$1$2; node$1$message$1$6, node$1$has_lock$0$3; node$1$message$0$12; node$1$message$0$13; node$1$message$0$14; node$1$message$0$15; node$1$message$1$11; node$1$message$1$15; node$1$message$1$3; node$1$message$1$7]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$0; node$1$message$1$12; node$1$message$1$4; node$1$message$1$8 | node$1$has_lock$0$1; node$1$message$0$4; node$1$message$0$5; node$1$message$0$6; node$1$message$0$7; node$1$message$1$1; node$1$message$1$13; node$1$message$1$5; node$1$message$1$9 | node$1$has_lock$0$2; node$1$message$0$10; node$1$message$0$11; node$1$message$0$8; node$1$message$0$9; node$1$message$1$10; node$1$message$1$14; node$1$message$1$2; node$1$message$1$6 | node$1$has_lock$0$3; node$1$message$0$12; node$1$message$0$13; node$1$message$0$14; node$1$message$0$15; node$1$message$1$11; node$1$message$1$15; node$1$message$1$3; node$1$message$1$7}

part_sig: ('node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$0; node$1$message$1$12; node$1$message$1$4; node$1$message$1$8 | node$1$has_lock$0$1; node$1$message$0$4; node$1$message$0$5; node$1$message$0$6; node$1$message$0$7; node$1$message$1$1; node$1$message$1$13; node$1$message$1$5; node$1$message$1$9 | node$1$has_lock$0$2; node$1$message$0$10; node$1$message$0$11; node$1$message$0$8; node$1$message$0$9; node$1$message$1$10; node$1$message$1$14; node$1$message$1$2; node$1$message$1$6 | node$1$has_lock$0$3; node$1$message$0$12; node$1$message$0$13; node$1$message$0$14; node$1$message$0$15; node$1$message$1$11; node$1$message$1$15; node$1$message$1$3; node$1$message$1$7',)


---------- SigGenerator ----------

terms:  ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~has_lock(node3)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node0,node3)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node1,node3)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)', '~message(node2,node3)', '~message(node3,node0)', '~message(node3,node1)', '~message(node3,node2)', '~message(node3,node3)']

func_name2symbol:  {'has_lock': Const('has_lock', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort())), 'message': Const('message', FunctionSort(EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), BooleanSort()))}

func_name2args_sort:  {'has_lock': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')),), 'message': (EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')), EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}

sign_func_name2count:  {'1$has_lock': 4, '1$message': 16}


---------- ProductArgPartition ----------

sort2class_sigs: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$0; node$1$message$1$12; node$1$message$1$4; node$1$message$1$8, node$1$has_lock$0$1; node$1$message$0$4; node$1$message$0$5; node$1$message$0$6; node$1$message$0$7; node$1$message$1$1; node$1$message$1$13; node$1$message$1$5; node$1$message$1$9, node$1$has_lock$0$2; node$1$message$0$10; node$1$message$0$11; node$1$message$0$8; node$1$message$0$9; node$1$message$1$10; node$1$message$1$14; node$1$message$1$2; node$1$message$1$6, node$1$has_lock$0$3; node$1$message$0$12; node$1$message$0$13; node$1$message$0$14; node$1$message$0$15; node$1$message$1$11; node$1$message$1$15; node$1$message$1$3; node$1$message$1$7]}

sort2part_sig: {EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')): node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$0; node$1$message$1$12; node$1$message$1$4; node$1$message$1$8 | node$1$has_lock$0$1; node$1$message$0$4; node$1$message$0$5; node$1$message$0$6; node$1$message$0$7; node$1$message$1$1; node$1$message$1$13; node$1$message$1$5; node$1$message$1$9 | node$1$has_lock$0$2; node$1$message$0$10; node$1$message$0$11; node$1$message$0$8; node$1$message$0$9; node$1$message$1$10; node$1$message$1$14; node$1$message$1$2; node$1$message$1$6 | node$1$has_lock$0$3; node$1$message$0$12; node$1$message$0$13; node$1$message$0$14; node$1$message$0$15; node$1$message$1$11; node$1$message$1$15; node$1$message$1$3; node$1$message$1$7}

	sort: node

	identical_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0; node$1$message$0$0; node$1$message$0$1; node$1$message$0$2; node$1$message$0$3; node$1$message$1$0; node$1$message$1$12; node$1$message$1$4; node$1$message$1$8, node$1$has_lock$0$1; node$1$message$0$4; node$1$message$0$5; node$1$message$0$6; node$1$message$0$7; node$1$message$1$1; node$1$message$1$13; node$1$message$1$5; node$1$message$1$9, node$1$has_lock$0$2; node$1$message$0$10; node$1$message$0$11; node$1$message$0$8; node$1$message$0$9; node$1$message$1$10; node$1$message$1$14; node$1$message$1$2; node$1$message$1$6, node$1$has_lock$0$3; node$1$message$0$12; node$1$message$0$13; node$1$message$0$14; node$1$message$0$15; node$1$message$1$11; node$1$message$1$15; node$1$message$1$3; node$1$message$1$7]}

	identical_single_classes: {}

	identical_multi_classes: {'node$1$has_lock$0; node$1$message$0; node$1$message$0; node$1$message$0; node$1$message$0; node$1$message$1; node$1$message$1; node$1$message$1; node$1$message$1': [node$1$has_lock$0$0, node$1$message$0$0, node$1$message$0$1, node$1$message$0$2, node$1$message$0$3, node$1$message$1$0, node$1$message$1$12, node$1$message$1$4, node$1$message$1$8, node$1$has_lock$0$1, node$1$message$0$4, node$1$message$0$5, node$1$message$0$6, node$1$message$0$7, node$1$message$1$1, node$1$message$1$13, node$1$message$1$5, node$1$message$1$9, node$1$has_lock$0$2, node$1$message$0$10, node$1$message$0$11, node$1$message$0$8, node$1$message$0$9, node$1$message$1$10, node$1$message$1$14, node$1$message$1$2, node$1$message$1$6, node$1$has_lock$0$3, node$1$message$0$12, node$1$message$0$13, node$1$message$0$14, node$1$message$0$15, node$1$message$1$11, node$1$message$1$15, node$1$message$1$3, node$1$message$1$7]}


---------- QInference: _set_sort_to_quantifier_mode ----------

quantifier mode: node: QuantifierMode.exists


---------- QInference: _set_constraint_mode ----------

constraint mode: ConstraintMode.no_merge


---------- QFormula: _set_qvars ----------

forall_qvars: set()

exists_qvars: {Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))}


---------- QFormula: _set_signed_func_name_to_args ----------

signed_func_name2args: {'1$has_lock': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]], '1$message': [[Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))], [Var('NODE0', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3'))), Var('NODE1', EnumeratedSort('node', ('node0', 'node1', 'node2', 'node3')))]]}


---------- QFormula: _set_qterms ----------

qterms: ['~message(NODE0,NODE1)', '~has_lock(NODE0)']


---------- QFormula: get_qclause ----------

qclause: exists NODE1,NODE0. message(NODE0,NODE1) | has_lock(NODE0)


===============================================================================================================

	[QI RESULT]: Quantified Prime Orbits on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

===============================================================================================================


=== Prime Orbit 0 =====================
size : 24
num_suborbits: 1
0 (*) : ---------------1-1------
0     : ['message(node2,node3)', 'message(node3,node1)']
1     : -------------1----1-----
1     : ['message(node2,node1)', 'message(node3,node2)']
2     : -----------1------1-----
2     : ['message(node1,node3)', 'message(node3,node2)']
3     : ----------1------1------
3     : ['message(node1,node2)', 'message(node3,node1)']
4     : ----------1----1--------
4     : ['message(node1,node2)', 'message(node2,node3)']
5     : -----------1-1----------
5     : ['message(node1,node3)', 'message(node2,node1)']
6     : ---------------11-------
6     : ['message(node2,node3)', 'message(node3,node0)']
7     : ------------1-----1-----
7     : ['message(node2,node0)', 'message(node3,node2)']
8     : -------1----------1-----
8     : ['message(node0,node3)', 'message(node3,node2)']
9     : ------1---------1-------
9     : ['message(node0,node2)', 'message(node3,node0)']
10     : ------1--------1--------
10     : ['message(node0,node2)', 'message(node2,node3)']
11     : -------1----1-----------
11     : ['message(node0,node3)', 'message(node2,node0)']
12     : -----------1----1-------
12     : ['message(node1,node3)', 'message(node3,node0)']
13     : --------1--------1------
13     : ['message(node1,node0)', 'message(node3,node1)']
14     : -------1---------1------
14     : ['message(node0,node3)', 'message(node3,node1)']
15     : -----1----------1-------
15     : ['message(node0,node1)', 'message(node3,node0)']
16     : -----1-----1------------
16     : ['message(node0,node1)', 'message(node1,node3)']
17     : -------11---------------
17     : ['message(node0,node3)', 'message(node1,node0)']
18     : ----------1-1-----------
18     : ['message(node1,node2)', 'message(node2,node0)']
19     : --------1----1----------
19     : ['message(node1,node0)', 'message(node2,node1)']
20     : ------1------1----------
20     : ['message(node0,node2)', 'message(node2,node1)']
21     : -----1------1-----------
21     : ['message(node0,node1)', 'message(node2,node0)']
22     : -----1----1-------------
22     : ['message(node0,node1)', 'message(node1,node2)']
23     : ------1-1---------------
23     : ['message(node0,node2)', 'message(node1,node0)']
num_forall :   3
num_exists :   0
num_literals : 5
quantified form : forall NODE1,NODE0,NODE2. ~message(NODE1,NODE2) | ~message(NODE0,NODE1) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)
qcost : 8




=== Prime Orbit 1 =====================
size : 24
num_suborbits: 1
24 (*) : 1--------------1--------
24     : ['has_lock(node0)', 'message(node2,node3)']
25     : 1-----------------1-----
25     : ['has_lock(node0)', 'message(node3,node2)']
26     : 1----------1------------
26     : ['has_lock(node0)', 'message(node1,node3)']
27     : 1----------------1------
27     : ['has_lock(node0)', 'message(node3,node1)']
28     : 1---------1-------------
28     : ['has_lock(node0)', 'message(node1,node2)']
29     : 1------------1----------
29     : ['has_lock(node0)', 'message(node2,node1)']
30     : -1-------------1--------
30     : ['has_lock(node1)', 'message(node2,node3)']
31     : -1----------------1-----
31     : ['has_lock(node1)', 'message(node3,node2)']
32     : -1-----1----------------
32     : ['has_lock(node1)', 'message(node0,node3)']
33     : -1--------------1-------
33     : ['has_lock(node1)', 'message(node3,node0)']
34     : -1----1-----------------
34     : ['has_lock(node1)', 'message(node0,node2)']
35     : -1----------1-----------
35     : ['has_lock(node1)', 'message(node2,node0)']
36     : --1--------1------------
36     : ['has_lock(node2)', 'message(node1,node3)']
37     : --1--------------1------
37     : ['has_lock(node2)', 'message(node3,node1)']
38     : --1----1----------------
38     : ['has_lock(node2)', 'message(node0,node3)']
39     : --1-------------1-------
39     : ['has_lock(node2)', 'message(node3,node0)']
40     : --1--1------------------
40     : ['has_lock(node2)', 'message(node0,node1)']
41     : --1-----1---------------
41     : ['has_lock(node2)', 'message(node1,node0)']
42     : ---1------1-------------
42     : ['has_lock(node3)', 'message(node1,node2)']
43     : ---1---------1----------
43     : ['has_lock(node3)', 'message(node2,node1)']
44     : ---1--1-----------------
44     : ['has_lock(node3)', 'message(node0,node2)']
45     : ---1--------1-----------
45     : ['has_lock(node3)', 'message(node2,node0)']
46     : ---1-1------------------
46     : ['has_lock(node3)', 'message(node0,node1)']
47     : ---1----1---------------
47     : ['has_lock(node3)', 'message(node1,node0)']
num_forall :   3
num_exists :   0
num_literals : 5
quantified form : forall NODE1,NODE0,NODE2. ~has_lock(NODE0) | ~message(NODE1,NODE2) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)
qcost : 8




=== Prime Orbit 2 =====================
size : 12
num_suborbits: 1
48 (*) : --1------------1--------
48     : ['has_lock(node2)', 'message(node2,node3)']
49     : ---1--------------1-----
49     : ['has_lock(node3)', 'message(node3,node2)']
50     : -1---------1------------
50     : ['has_lock(node1)', 'message(node1,node3)']
51     : ---1-------------1------
51     : ['has_lock(node3)', 'message(node3,node1)']
52     : -1--------1-------------
52     : ['has_lock(node1)', 'message(node1,node2)']
53     : --1----------1----------
53     : ['has_lock(node2)', 'message(node2,node1)']
54     : 1------1----------------
54     : ['has_lock(node0)', 'message(node0,node3)']
55     : ---1------------1-------
55     : ['has_lock(node3)', 'message(node3,node0)']
56     : 1-----1-----------------
56     : ['has_lock(node0)', 'message(node0,node2)']
57     : --1---------1-----------
57     : ['has_lock(node2)', 'message(node2,node0)']
58     : 1----1------------------
58     : ['has_lock(node0)', 'message(node0,node1)']
59     : -1------1---------------
59     : ['has_lock(node1)', 'message(node1,node0)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 3 =====================
size : 12
num_suborbits: 1
60 (*) : ---1-----------1--------
60     : ['has_lock(node3)', 'message(node2,node3)']
61     : --1---------------1-----
61     : ['has_lock(node2)', 'message(node3,node2)']
62     : ---1-------1------------
62     : ['has_lock(node3)', 'message(node1,node3)']
63     : -1---------------1------
63     : ['has_lock(node1)', 'message(node3,node1)']
64     : --1-------1-------------
64     : ['has_lock(node2)', 'message(node1,node2)']
65     : -1-----------1----------
65     : ['has_lock(node1)', 'message(node2,node1)']
66     : ---1---1----------------
66     : ['has_lock(node3)', 'message(node0,node3)']
67     : 1---------------1-------
67     : ['has_lock(node0)', 'message(node3,node0)']
68     : --1---1-----------------
68     : ['has_lock(node2)', 'message(node0,node2)']
69     : 1-----------1-----------
69     : ['has_lock(node0)', 'message(node2,node0)']
70     : -1---1------------------
70     : ['has_lock(node1)', 'message(node0,node1)']
71     : 1-------1---------------
71     : ['has_lock(node0)', 'message(node1,node0)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 4 =====================
size : 24
num_suborbits: 1
72 (*) : ----1----------1--------
72     : ['message(node0,node0)', 'message(node2,node3)']
73     : ----1-------------1-----
73     : ['message(node0,node0)', 'message(node3,node2)']
74     : ----1------1------------
74     : ['message(node0,node0)', 'message(node1,node3)']
75     : ----1------------1------
75     : ['message(node0,node0)', 'message(node3,node1)']
76     : ----1-----1-------------
76     : ['message(node0,node0)', 'message(node1,node2)']
77     : ----1--------1----------
77     : ['message(node0,node0)', 'message(node2,node1)']
78     : ---------1-----1--------
78     : ['message(node1,node1)', 'message(node2,node3)']
79     : ---------1--------1-----
79     : ['message(node1,node1)', 'message(node3,node2)']
80     : -------1-1--------------
80     : ['message(node0,node3)', 'message(node1,node1)']
81     : ---------1------1-------
81     : ['message(node1,node1)', 'message(node3,node0)']
82     : ------1--1--------------
82     : ['message(node0,node2)', 'message(node1,node1)']
83     : ---------1--1-----------
83     : ['message(node1,node1)', 'message(node2,node0)']
84     : -----------1--1---------
84     : ['message(node1,node3)', 'message(node2,node2)']
85     : --------------1--1------
85     : ['message(node2,node2)', 'message(node3,node1)']
86     : -------1------1---------
86     : ['message(node0,node3)', 'message(node2,node2)']
87     : --------------1-1-------
87     : ['message(node2,node2)', 'message(node3,node0)']
88     : -----1--------1---------
88     : ['message(node0,node1)', 'message(node2,node2)']
89     : --------1-----1---------
89     : ['message(node1,node0)', 'message(node2,node2)']
90     : ----------1--------1----
90     : ['message(node1,node2)', 'message(node3,node3)']
91     : -------------1-----1----
91     : ['message(node2,node1)', 'message(node3,node3)']
92     : ------1------------1----
92     : ['message(node0,node2)', 'message(node3,node3)']
93     : ------------1------1----
93     : ['message(node2,node0)', 'message(node3,node3)']
94     : -----1-------------1----
94     : ['message(node0,node1)', 'message(node3,node3)']
95     : --------1----------1----
95     : ['message(node1,node0)', 'message(node3,node3)']
num_forall :   3
num_exists :   0
num_literals : 5
quantified form : forall NODE1,NODE0,NODE2. ~message(NODE1,NODE2) | ~message(NODE0,NODE0) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)
qcost : 8




=== Prime Orbit 5 =====================
size : 12
num_suborbits: 1
96 (*) : -----1---------1--------
96     : ['message(node0,node1)', 'message(node2,node3)']
97     : -----1------------1-----
97     : ['message(node0,node1)', 'message(node3,node2)']
98     : ------1----1------------
98     : ['message(node0,node2)', 'message(node1,node3)']
99     : ------1----------1------
99     : ['message(node0,node2)', 'message(node3,node1)']
100     : -------1--1-------------
100     : ['message(node0,node3)', 'message(node1,node2)']
101     : -------1-----1----------
101     : ['message(node0,node3)', 'message(node2,node1)']
102     : --------1------1--------
102     : ['message(node1,node0)', 'message(node2,node3)']
103     : --------1---------1-----
103     : ['message(node1,node0)', 'message(node3,node2)']
104     : ----------1-----1-------
104     : ['message(node1,node2)', 'message(node3,node0)']
105     : -----------11-----------
105     : ['message(node1,node3)', 'message(node2,node0)']
106     : ------------1----1------
106     : ['message(node2,node0)', 'message(node3,node1)']
107     : -------------1--1-------
107     : ['message(node2,node1)', 'message(node3,node0)']
num_forall :   4
num_exists :   0
num_literals : 8
quantified form : forall NODE1,NODE3,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE1,NODE3) | (NODE0 = NODE3 | NODE1 = NODE3 | NODE0 = NODE2 | NODE2 = NODE3 | NODE0 = NODE1 | NODE1 = NODE2)
qcost : 12




=== Prime Orbit 6 =====================
size : 12
num_suborbits: 1
108 (*) : -------1-------1--------
108     : ['message(node0,node3)', 'message(node2,node3)']
109     : ------1-----------1-----
109     : ['message(node0,node2)', 'message(node3,node2)']
110     : -------1---1------------
110     : ['message(node0,node3)', 'message(node1,node3)']
111     : -----1-----------1------
111     : ['message(node0,node1)', 'message(node3,node1)']
112     : ------1---1-------------
112     : ['message(node0,node2)', 'message(node1,node2)']
113     : -----1-------1----------
113     : ['message(node0,node1)', 'message(node2,node1)']
114     : -----------1---1--------
114     : ['message(node1,node3)', 'message(node2,node3)']
115     : ----------1-------1-----
115     : ['message(node1,node2)', 'message(node3,node2)']
116     : --------1-------1-------
116     : ['message(node1,node0)', 'message(node3,node0)']
117     : --------1---1-----------
117     : ['message(node1,node0)', 'message(node2,node0)']
118     : -------------1---1------
118     : ['message(node2,node1)', 'message(node3,node1)']
119     : ------------1---1-------
119     : ['message(node2,node0)', 'message(node3,node0)']
num_forall :   3
num_exists :   0
num_literals : 5
quantified form : forall NODE1,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE1,NODE2) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)
qcost : 8




=== Prime Orbit 7 =====================
size : 12
num_suborbits: 1
120 (*) : ------------1--1--------
120     : ['message(node2,node0)', 'message(node2,node3)']
121     : ----------------1-1-----
121     : ['message(node3,node0)', 'message(node3,node2)']
122     : --------1--1------------
122     : ['message(node1,node0)', 'message(node1,node3)']
123     : ----------------11------
123     : ['message(node3,node0)', 'message(node3,node1)']
124     : --------1-1-------------
124     : ['message(node1,node0)', 'message(node1,node2)']
125     : ------------11----------
125     : ['message(node2,node0)', 'message(node2,node1)']
126     : -------------1-1--------
126     : ['message(node2,node1)', 'message(node2,node3)']
127     : -----------------11-----
127     : ['message(node3,node1)', 'message(node3,node2)']
128     : -----1-1----------------
128     : ['message(node0,node1)', 'message(node0,node3)']
129     : -----11-----------------
129     : ['message(node0,node1)', 'message(node0,node2)']
130     : ----------11------------
130     : ['message(node1,node2)', 'message(node1,node3)']
131     : ------11----------------
131     : ['message(node0,node2)', 'message(node0,node3)']
num_forall :   3
num_exists :   0
num_literals : 5
quantified form : forall NODE1,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE0,NODE1) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2)
qcost : 8




=== Prime Orbit 8 =====================
size : 12
num_suborbits: 1
132 (*) : --------------11--------
132     : ['message(node2,node2)', 'message(node2,node3)']
133     : ------------------11----
133     : ['message(node3,node2)', 'message(node3,node3)']
134     : ---------1-1------------
134     : ['message(node1,node1)', 'message(node1,node3)']
135     : -----------------1-1----
135     : ['message(node3,node1)', 'message(node3,node3)']
136     : ---------11-------------
136     : ['message(node1,node1)', 'message(node1,node2)']
137     : -------------11---------
137     : ['message(node2,node1)', 'message(node2,node2)']
138     : ----1--1----------------
138     : ['message(node0,node0)', 'message(node0,node3)']
139     : ----------------1--1----
139     : ['message(node3,node0)', 'message(node3,node3)']
140     : ----1-1-----------------
140     : ['message(node0,node0)', 'message(node0,node2)']
141     : ------------1-1---------
141     : ['message(node2,node0)', 'message(node2,node2)']
142     : ----11------------------
142     : ['message(node0,node0)', 'message(node0,node1)']
143     : --------11--------------
143     : ['message(node1,node0)', 'message(node1,node1)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 10 =====================
size : 6
num_suborbits: 1
150 (*) : 11----------------------
150     : ['has_lock(node0)', 'has_lock(node1)']
151     : 1-1---------------------
151     : ['has_lock(node0)', 'has_lock(node2)']
152     : 1--1--------------------
152     : ['has_lock(node0)', 'has_lock(node3)']
153     : -11---------------------
153     : ['has_lock(node1)', 'has_lock(node2)']
154     : -1-1--------------------
154     : ['has_lock(node1)', 'has_lock(node3)']
155     : --11--------------------
155     : ['has_lock(node2)', 'has_lock(node3)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~has_lock(NODE0) | ~has_lock(NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 11 =====================
size : 12
num_suborbits: 1
156 (*) : ---11-------------------
156     : ['has_lock(node3)', 'message(node0,node0)']
157     : --1-1-------------------
157     : ['has_lock(node2)', 'message(node0,node0)']
158     : -1--1-------------------
158     : ['has_lock(node1)', 'message(node0,node0)']
159     : ---1-----1--------------
159     : ['has_lock(node3)', 'message(node1,node1)']
160     : --1------1--------------
160     : ['has_lock(node2)', 'message(node1,node1)']
161     : 1--------1--------------
161     : ['has_lock(node0)', 'message(node1,node1)']
162     : ---1----------1---------
162     : ['has_lock(node3)', 'message(node2,node2)']
163     : -1------------1---------
163     : ['has_lock(node1)', 'message(node2,node2)']
164     : 1-------------1---------
164     : ['has_lock(node0)', 'message(node2,node2)']
165     : --1----------------1----
165     : ['has_lock(node2)', 'message(node3,node3)']
166     : -1-----------------1----
166     : ['has_lock(node1)', 'message(node3,node3)']
167     : 1------------------1----
167     : ['has_lock(node0)', 'message(node3,node3)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 12 =====================
size : 4
num_suborbits: 1
168 (*) : 1---1-------------------
168     : ['has_lock(node0)', 'message(node0,node0)']
169     : -1-------1--------------
169     : ['has_lock(node1)', 'message(node1,node1)']
170     : --1-----------1---------
170     : ['has_lock(node2)', 'message(node2,node2)']
171     : ---1---------------1----
171     : ['has_lock(node3)', 'message(node3,node3)']
num_forall :   1
num_exists :   0
num_literals : 2
quantified form : forall NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE0)
qcost : 3




=== Prime Orbit 13 =====================
size : 12
num_suborbits: 1
172 (*) : ----1---1---------------
172     : ['message(node0,node0)', 'message(node1,node0)']
173     : ----1-------1-----------
173     : ['message(node0,node0)', 'message(node2,node0)']
174     : ----1-----------1-------
174     : ['message(node0,node0)', 'message(node3,node0)']
175     : -----1---1--------------
175     : ['message(node0,node1)', 'message(node1,node1)']
176     : ---------1---1----------
176     : ['message(node1,node1)', 'message(node2,node1)']
177     : ---------1-------1------
177     : ['message(node1,node1)', 'message(node3,node1)']
178     : ------1-------1---------
178     : ['message(node0,node2)', 'message(node2,node2)']
179     : ----------1---1---------
179     : ['message(node1,node2)', 'message(node2,node2)']
180     : --------------1---1-----
180     : ['message(node2,node2)', 'message(node3,node2)']
181     : -------1-----------1----
181     : ['message(node0,node3)', 'message(node3,node3)']
182     : -----------1-------1----
182     : ['message(node1,node3)', 'message(node3,node3)']
183     : ---------------1---1----
183     : ['message(node2,node3)', 'message(node3,node3)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 14 =====================
size : 6
num_suborbits: 1
184 (*) : -----1--1---------------
184     : ['message(node0,node1)', 'message(node1,node0)']
185     : ------1-----1-----------
185     : ['message(node0,node2)', 'message(node2,node0)']
186     : -------1--------1-------
186     : ['message(node0,node3)', 'message(node3,node0)']
187     : ----------1--1----------
187     : ['message(node1,node2)', 'message(node2,node1)']
188     : -----------1-----1------
188     : ['message(node1,node3)', 'message(node3,node1)']
189     : ---------------1--1-----
189     : ['message(node2,node3)', 'message(node3,node2)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE1,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 15 =====================
size : 6
num_suborbits: 1
190 (*) : ----1----1--------------
190     : ['message(node0,node0)', 'message(node1,node1)']
191     : ----1---------1---------
191     : ['message(node0,node0)', 'message(node2,node2)']
192     : ----1--------------1----
192     : ['message(node0,node0)', 'message(node3,node3)']
193     : ---------1----1---------
193     : ['message(node1,node1)', 'message(node2,node2)']
194     : ---------1---------1----
194     : ['message(node1,node1)', 'message(node3,node3)']
195     : --------------1----1----
195     : ['message(node2,node2)', 'message(node3,node3)']
num_forall :   2
num_exists :   0
num_literals : 3
quantified form : forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1
qcost : 5




=== Prime Orbit 17 =====================
size : 1
num_suborbits: 1
197 (*) : 00000000000000000000----
197     : ['~has_lock(node0)', '~has_lock(node1)', '~has_lock(node2)', '~has_lock(node3)', '~message(node0,node0)', '~message(node0,node1)', '~message(node0,node2)', '~message(node0,node3)', '~message(node1,node0)', '~message(node1,node1)', '~message(node1,node2)', '~message(node1,node3)', '~message(node2,node0)', '~message(node2,node1)', '~message(node2,node2)', '~message(node2,node3)', '~message(node3,node0)', '~message(node3,node1)', '~message(node3,node2)', '~message(node3,node3)']
num_forall :   0
num_exists :   2
num_literals : 2
quantified form : exists NODE1,NODE0. message(NODE0,NODE1) | has_lock(NODE0)
qcost : 4



[QRM NOTE]: Time elapsed since start: 0.253 seconds

[QRM NOTE]: Time elapsed since last: 0.137 seconds

[QRM NOTE]: Peak memory: 2168739 bytes


==============================================================================================

	[MIN]: Minimization on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

==============================================================================================


New level: 1
 pending : []
 solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]


Before reduction : 
 pending  : []
 solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]

Essensial at level 1 : set()

Before removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1), (17, -1)]

After removed
 coverage : [(0, -1), (1, -1), (2, -1), (3, -1), (4, -1), (5, -1), (6, -1), (7, -1), (8, -1), (9, -1), (10, -1), (11, -1), (12, -1), (13, -1), (14, -1), (15, -1), (16, -1), (17, -1)]

Covered at level 1 : set()

After reduction : 
 pending  : []
 solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]


Solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17] has cost 99.


Before backtrack at level 1
 pending : []
 solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]

After backtrack at level 1
 pending : []
 solution : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]


=============================================================================================================

	[MIN RESULT]: Minimized Invariants on [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

=============================================================================================================

[MIN NOTE]: number of minimal solution found: 1

[MIN NOTE]: upper bound: 99

[MIN NOTE]: maximum branch and bound depth: 1

[MIN NOTE]: number of definitions: 0

[MIN NOTE]: number of equality relations: 0

[MIN NOTE]: Solution 0 : [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 15, 17]

[MIN NOTE]: solution length: 16

invariant [invar_0] forall NODE1,NODE0,NODE2. ~message(NODE1,NODE2) | ~message(NODE0,NODE1) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2) # qcost: 8

invariant [invar_1] forall NODE1,NODE0,NODE2. ~has_lock(NODE0) | ~message(NODE1,NODE2) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2) # qcost: 8

invariant [invar_2] forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_3] forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_4] forall NODE1,NODE0,NODE2. ~message(NODE1,NODE2) | ~message(NODE0,NODE0) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2) # qcost: 8

invariant [invar_5] forall NODE1,NODE3,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE1,NODE3) | (NODE0 = NODE3 | NODE1 = NODE3 | NODE0 = NODE2 | NODE2 = NODE3 | NODE0 = NODE1 | NODE1 = NODE2) # qcost: 12

invariant [invar_6] forall NODE1,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE1,NODE2) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2) # qcost: 8

invariant [invar_7] forall NODE1,NODE0,NODE2. ~message(NODE0,NODE2) | ~message(NODE0,NODE1) | (NODE0 = NODE1 | NODE0 = NODE2 | NODE1 = NODE2) # qcost: 8

invariant [invar_8] forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_10] forall NODE1,NODE0. ~has_lock(NODE0) | ~has_lock(NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_11] forall NODE1,NODE0. ~has_lock(NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_12] forall NODE0. ~has_lock(NODE0) | ~message(NODE0,NODE0) # qcost: 3

invariant [invar_13] forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE0) | NODE0 = NODE1 # qcost: 5

invariant [invar_14] forall NODE1,NODE0. ~message(NODE1,NODE0) | ~message(NODE0,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_15] forall NODE1,NODE0. ~message(NODE0,NODE0) | ~message(NODE1,NODE1) | NODE0 = NODE1 # qcost: 5

invariant [invar_17] exists NODE1,NODE0. message(NODE0,NODE1) | has_lock(NODE0) # qcost: 4

[MIN NOTE]: number of total invariants: 16

[MIN NOTE]: total qCost: 99




[QRM NOTE]: Time elapsed since start: 0.306 seconds

[QRM NOTE]: Time elapsed since last: 0.053 seconds

[QRM NOTE]: Peak memory: 2118416 bytes


**************************************************************************************************************

	[Reachability Convergence Check]: [ivybench/sym/ivy/simple-decentralized-lock.ivy: node=4]

**************************************************************************************************************

python3 qrm.py ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy -s node=5 -f 2 -g -w -r -m -v 5 -w -l ivybench/sym/ivy/simple-decentralized-lock.log


---------- Parsing Ivy ----------


Printing isolate this:

OK


==============================================================================================================

	[FW]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: node=5]

==============================================================================================================


==============================================

	Set up for forward reachability

==============================================

[FW NOTE]: number of state atoms: 35

[FW NOTE]: number of interpreted atoms (e.g. member,le): 0

[FW NOTE]: symmetric group order: 120

[FW NOTE]: number of branching actions: 50

ivy_to_cpp target=qrm simple-decentralized-lock.node_5.finite.ivy

[IVY_TO_CPP RESULT]: OK

swig -c++ -python -o simple-decentralized-lock.node_5.finite_wrap.cpp ivy_exec.i

[SWIG RESULT]: OK

g++ -std=c++11 -fpic -pthread -O3 simple-decentralized-lock.node_5.finite.cpp simple-decentralized-lock.node_5.finite_wrap.cpp -I/home/yunrong/.pyenv/versions/3.12.0/include/python3.12 -c

[G++ RESULT]: OK

g++ -shared simple-decentralized-lock.node_5.finite.o simple-decentralized-lock.node_5.finite_wrap.o -o _ivy_exec.so -lm -lstdc++

[LINK RESULT]: OK

[QRM NOTE]: Time elapsed since start: 6.283 seconds

[QRM NOTE]: Time elapsed since last: 6.283 seconds

[QRM NOTE]: Peak memory: 1196226 bytes


===================================

	Forward reachability

===================================

[FW NOTE]: dfs max depth: 3

[FW NOTE]: number of total reachable states:        150

[FW NOTE]: number of dfs representative states:     7

[FW NOTE]: number of dfs non-representative states: 143


=====================================================================================================================

	[FW RESULT]: Forward Reachability on [ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: node=5]

=====================================================================================================================

sort: node=['node0', 'node1', 'node2', 'node3', 'node4']
predicate: message('node', 'node')
predicate: start_node=('node',)
predicate: has_lock('node',)
interpreted atoms: {}
state atoms: ['has_lock(node0)', 'has_lock(node1)', 'has_lock(node2)', 'has_lock(node3)', 'has_lock(node4)', 'message(node0,node0)', 'message(node0,node1)', 'message(node0,node2)', 'message(node0,node3)', 'message(node0,node4)', 'message(node1,node0)', 'message(node1,node1)', 'message(node1,node2)', 'message(node1,node3)', 'message(node1,node4)', 'message(node2,node0)', 'message(node2,node1)', 'message(node2,node2)', 'message(node2,node3)', 'message(node2,node4)', 'message(node3,node0)', 'message(node3,node1)', 'message(node3,node2)', 'message(node3,node3)', 'message(node3,node4)', 'message(node4,node0)', 'message(node4,node1)', 'message(node4,node2)', 'message(node4,node3)', 'message(node4,node4)', '(start_node=node0)', '(start_node=node1)', '(start_node=node2)', '(start_node=node3)', '(start_node=node4)']
representative states : 1073741825, 33, 65, 1073741826, 66, 34, 68


=== State Orbit 0 =====================
size : 5
repr state: 10000000000000000000000000000010000
lex min decimal: 1073741825
states:
01000000000000000000000000000001000
00001000000000000000000000000000001
00100000000000000000000000000000100
10000000000000000000000000000010000
00010000000000000000000000000000010




=== State Orbit 1 =====================
size : 5
repr state: 00000100000000000000000000000010000
lex min decimal: 33
states:
00000000000000000000000000000100001
00000100000000000000000000000010000
00000000000000000100000000000000100
00000000000100000000000000000001000
00000000000000000000000100000000010




=== State Orbit 2 =====================
size : 20
repr state: 00000010000000000000000000000010000
lex min decimal: 65
states:
00000010000000000000000000000010000
00000000000001000000000000000001000
00000000000000100000000000000001000
00000000000000000000000000001000001
00000000000000001000000000000000100
00000000000000000000000010000000010
00000001000000000000000000000010000
00000000000000000001000000000000100
00000000000000000000001000000000010
00000000000000000000000000100000001
00000000010000000000000000000010000
00000000000000000000100000000000010
00000000000000010000000000000000100
00000000000000000000000000010000001
00000000000000000000000001000000001
00000000100000000000000000000010000
00000000000000000010000000000000100
00000000000000000000010000000000010
00000000001000000000000000000001000
00000000000010000000000000000001000




=== State Orbit 3 =====================
size : 20
repr state: 01000000000000000000000000000010000
lex min decimal: 1073741826
states:
00001000000000000000000000000000010
00100000000000000000000000000001000
10000000000000000000000000000000100
00001000000000000000000000000010000
00100000000000000000000000000010000
00010000000000000000000000000000001
01000000000000000000000000000000100
10000000000000000000000000000001000
00100000000000000000000000000000001
01000000000000000000000000000010000
00010000000000000000000000000001000
00010000000000000000000000000000100
00100000000000000000000000000000010
01000000000000000000000000000000001
01000000000000000000000000000000010
00010000000000000000000000000010000
10000000000000000000000000000000001
00001000000000000000000000000001000
10000000000000000000000000000000010
00001000000000000000000000000000100




=== State Orbit 4 =====================
size : 20
repr state: 00000000001000000000000000000010000
lex min decimal: 66
states:
00000000000000010000000000000010000
00000000100000000000000000000000010
00000000000000000010000000000000010
00000000000000001000000000000001000
00000000000000000000010000000001000
00000000000000000001000000000000001
00000000000000000000000001000010000
00000000010000000000000000000000001
00000000000000000000000000001000010
00000000000001000000000000000000010
00000000000000000000000000010000100
00000000000000000000000000100001000
00000000000000100000000000000000001
00000000000010000000000000000000100
00000000001000000000000000000010000
00000010000000000000000000000001000
00000000000000000000001000000000100
00000001000000000000000000000000100
00000000000000000000100000000010000
00000000000000000000000010000000001




=== State Orbit 5 =====================
size : 20
repr state: 00000000000100000000000000000010000
lex min decimal: 34
states:
00000000000000000000000000000110000
00000000000000000100000000000001000
00000000000000000000000000000101000
00000000000000000000000000000100010
00000000000000000100000000000010000
00000100000000000000000000000000010
00000000000000000000000000000100100
00000100000000000000000000000001000
00000000000100000000000000000000010
00000100000000000000000000000000001
00000000000100000000000000000010000
00000000000000000100000000000000001
00000000000100000000000000000000100
00000000000000000000000100000001000
00000100000000000000000000000000100
00000000000100000000000000000000001
00000000000000000000000100000000100
00000000000000000000000100000000001
00000000000000000100000000000000010
00000000000000000000000100000010000




=== State Orbit 6 =====================
size : 60
repr state: 00000000000010000000000000000010000
lex min decimal: 68
states:
00000010000000000000000000000000001
00000000100000000000000000000000001
00000000000000000001000000000001000
00000000000000000010000000000010000
00000000010000000000000000000000010
00000000000000001000000000000010000
00000000000000010000000000000000001
00000000100000000000000000000001000
00000000000000000000001000000000001
00000000000000001000000000000000010
00000000000000000000010000000010000
00000000000000100000000000000010000
00000001000000000000000000000000001
00000000000000000000000000100000100
00000000001000000000000000000000010
00000000000000000000001000000010000
00000000000000001000000000000000001
00000000000000000000000000100010000
00000000000001000000000000000010000
00000000000000000000000010000000100
00000000001000000000000000000000001
00000000000000000000100000000000001
00000000100000000000000000000000100
00000000000000000000000000001000100
00000000000000000000000000001001000
00000000010000000000000000000001000
00000000000000000000000000010001000
00000000000001000000000000000000100
00000001000000000000000000000000010
00000000000010000000000000000000001
00000000000000000000000010000010000
00000000000000000000000001000001000
00000000000000000000000001000000100
00000000000000000001000000000010000
00000000000000000000000000010010000
00000000000000000010000000000001000
00000010000000000000000000000000100
00000000000000000000000010000001000
00000000001000000000000000000000100
00000000000010000000000000000010000
00000000000000000000100000000001000
00000000000000000001000000000000010
00000000000000000000001000000001000
00000000000000000000100000000000100
00000000000010000000000000000000010
00000000000000000000000000010000010
00000000010000000000000000000000100
00000000000000000000000000100000010
00000000000000000000000001000000010
00000000000000100000000000000000100
00000000000000000000000000001010000
00000001000000000000000000000001000
00000000000000010000000000000000010
00000000000000000000010000000000100
00000000000000010000000000000001000
00000010000000000000000000000000010
00000000000000000010000000000000001
00000000000001000000000000000000001
00000000000000000000010000000000001
00000000000000100000000000000000010



[QRM NOTE]: Time elapsed since start: 6.688 seconds

[QRM NOTE]: Time elapsed since last: 0.406 seconds

[QRM NOTE]: Peak memory: 1278186 bytes


==========================================================================================================================================

	[REACH_CHECK]: Reachability Convergence Check for Rmin on [ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: node=5]

==========================================================================================================================================

[REACH_CHECK RESULT]: PASS

[QRM NOTE]: Time elapsed since start: 8.225 seconds

[QRM NOTE]: Time elapsed since last: 1.537 seconds

[QRM NOTE]: Peak memory: 1430005 bytes


*********************************************************************

	[IVY_CHECK]: Ivy Check for Reachability Invariant

*********************************************************************


==================================================================================================

	[IVY_CHECK]: Ivy check on [ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy]

==================================================================================================

ivy_check complete=fo ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy


Isolate this:

    The inductive invariant consists of the following conjectures:
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 39: invar_0
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 40: invar_1
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 41: invar_2
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 42: invar_3
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 43: invar_4
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 44: invar_5
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 45: invar_6
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 46: invar_7
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 47: invar_8
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 48: invar_10
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 49: invar_11
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 50: invar_12
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 51: invar_13
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 52: invar_14
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 53: invar_15
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 54: invar_17

    The following action implementations are present:
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 23: implementation of recv
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 17: implementation of send

    The following initializers are present:
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 12: init[after1]

    Initialization must establish the invariant
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 39: invar_0 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 40: invar_1 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 41: invar_2 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 42: invar_3 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 43: invar_4 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 44: invar_5 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 45: invar_6 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 46: invar_7 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 47: invar_8 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 48: invar_10 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 49: invar_11 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 50: invar_12 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 51: invar_13 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 52: invar_14 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 53: invar_15 ... PASS
        ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 54: invar_17 ... PASS

    The following set of external actions must preserve the invariant:
        (internal) ext:recv
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 39: invar_0 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 40: invar_1 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 41: invar_2 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 42: invar_3 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 43: invar_4 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 44: invar_5 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 45: invar_6 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 46: invar_7 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 47: invar_8 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 48: invar_10 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 49: invar_11 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 50: invar_12 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 51: invar_13 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 52: invar_14 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 53: invar_15 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 54: invar_17 ... PASS
        (internal) ext:send
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 39: invar_0 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 40: invar_1 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 41: invar_2 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 42: invar_3 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 43: invar_4 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 44: invar_5 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 45: invar_6 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 46: invar_7 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 47: invar_8 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 48: invar_10 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 49: invar_11 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 50: invar_12 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 51: invar_13 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 52: invar_14 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 53: invar_15 ... PASS
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 54: invar_17 ... PASS

    The following program assertions are treated as assumptions:
        in action send when called from the environment:
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 18: assumption
        in action recv when called from the environment:
            ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy: line 24: assumption

OK
[IVY_CHECK RESULT]: PASS


**********************************************************************************

	[QRM]: ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy

**********************************************************************************

[RMIN NUM]: 1

[RMIN RESULT]: ['ivybench/sym/ivy/simple-decentralized-lock.node_4.0.ivy']

[CUTOFF]: node=4

[QRM RESULT]: PASS

[QRM NOTE]: Time elapsed since start: 56.535 seconds

[QRM NOTE]: Time elapsed since last: 56.535 seconds

