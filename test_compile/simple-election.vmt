(declare-sort acceptor 0)
(declare-sort proposer 0)
(declare-sort quorum 0)

(define-fun .acceptor ((S acceptor)) acceptor (! S :sort 0))
(define-fun .proposer ((S proposer)) proposer (! S :sort 0))
(define-fun .quorum ((S quorum)) quorum (! S :sort 0))




(declare-fun __didNotPromise (acceptor) Bool)
(declare-fun __leader (proposer) Bool)
(declare-fun __promise (acceptor proposer) Bool)
(declare-fun __start (proposer) Bool)
(declare-fun chosenAt (quorum proposer) Bool)
(declare-fun leader (proposer) Bool)
(declare-fun member (acceptor quorum) Bool)
(declare-fun promise (acceptor proposer) Bool)
(declare-fun start (proposer) Bool)

(define-fun .def_chosenAt () Bool (! 
 (let (($v forall V1,V0. chosenAt(V0,V1) = (forall A. member(A,V0) -> promise(A,V1))
 ))
 (and $v))
 :definition chosenAt))

(define-fun .def_chosenAt () Bool (! 
 (let (($v forall V1,V0. chosenAt(V0,V1) = (forall A. member(A,V0) -> promise(A,V1))
 ))
 (and $v))
 :definition chosenAt))

(define-fun .def_didNotPromise () Bool (! 
 (let (($v forall V0. didNotPromise(V0) = (forall P. ~promise(V0,P))
 ))
 (and $v))
 :definition didNotPromise))

(define-fun .def_didNotPromise () Bool (! 
 (let (($v forall V0. didNotPromise(V0) = (forall P. ~promise(V0,P))
 ))
 (and $v))
 :definition didNotPromise))

(define-fun .prop () Bool (! 
 (let (($v ((forall P2,P1. (leader(P1) & leader(P2)) -> P1 = P2))
 ))
 (and $v))
 :invar-property 0))

(define-fun .axiom () Bool (! 
 (let (($v ((forall Q1,Q2. (exists A. (member(A,Q1) & member(A,Q2)))))
 ))
 (and $v))
 :axiom true))

(define-fun .init () Bool (! 
 (let (($v ((forall V0. start(V0) <-> false) & (forall V1,V0. promise(V0,V1) <-> false) & (forall V0. leader(V0) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:decide () Bool (! 
 (let (($v exists V__fml:p,V__fml:q. ((forall V0. leader(V0) <-> (true if (V0 = V__fml:p) else __leader(V0))) & chosenAt(V__fml:q,V__fml:p))
 ))
 (and $v))
 :action ext:decide))

(define-fun .action_ext:send_1a () Bool (! 
 (let (($v exists V__fml:p. ((forall V0. start(V0) <-> (true if (V0 = V__fml:p) else __start(V0))))
 ))
 (and $v))
 :action ext:send_1a))

(define-fun .action_ext:send_1b () Bool (! 
 (let (($v exists V__fml:p,V__fml:a. ((forall V1,V0. promise(V0,V1) <-> (true if (V0 = V__fml:a & V1 = V__fml:p) else __promise(V0,V1))) & start(V__fml:p) & __didNotPromise(V__fml:a))
 ))
 (and $v))
 :action ext:send_1b))

