(declare-sort node 0)
(declare-sort nset 0)

(define-fun .node ((S node)) node (! S :sort 0))
(define-fun .nset ((S nset)) nset (! S :sort 0))




(declare-fun __isleader (node) Bool)
(declare-fun __voted (node node) Bool)
(declare-fun isleader (node) Bool)
(declare-fun majority (nset) Bool)
(declare-fun member (node nset) Bool)
(declare-fun voted (node node) Bool)

(define-fun .prop () Bool (! 
 (let (($v ((forall M,N. (isleader(N) & isleader(M)) -> N = M))
 ))
 (and $v))
 :invar-property 0))

(define-fun .axiom () Bool (! 
 (let (($v ((forall S1,S2. (majority(S1) & majority(S2)) -> (exists N. (member(N,S1) & member(N,S2)))))
 ))
 (and $v))
 :axiom true))

(define-fun .init () Bool (! 
 (let (($v ((forall V1,V0. voted(V0,V1) <-> false) & (forall V0. isleader(V0) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:become_leader () Bool (! 
 (let (($v exists V__fml:s,V__fml:n. ((forall V0. isleader(V0) <-> (true if (V0 = V__fml:n) else __isleader(V0))) & majority(V__fml:s) & (forall M. member(M,V__fml:s) -> voted(M,V__fml:n)))
 ))
 (and $v))
 :action ext:become_leader))

(define-fun .action_ext:vote () Bool (! 
 (let (($v exists V__fml:v,V__fml:n. ((forall V1,V0. voted(V0,V1) <-> (true if (V0 = V__fml:v & V1 = V__fml:n) else __voted(V0,V1))) & (forall M. ~__voted(V__fml:v,M)))
 ))
 (and $v))
 :action ext:vote))

