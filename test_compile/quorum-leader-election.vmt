(declare-sort node 0)
(declare-sort nset 0)

(define-fun .node ((S node)) node (! S :sort 0))
(define-fun .nset ((S nset)) nset (! S :sort 0))

(declare-fun __isleader (node) Bool)
(declare-fun __voted (node node) Bool)

(declare-fun isleader (node) Bool)
(declare-fun voted (node node) Bool)

(define-fun .isleader ((V0 node)) Bool (! (__isleader V0) :next isleader))
(define-fun .voted ((V0 node) (V1 node)) Bool (! (__voted V0 V1) :next voted))

(declare-fun majority (nset) Bool)
(declare-fun member (node nset) Bool)

(define-fun .majority ((V0 nset)) Bool (! (majority V0) :global true))
(define-fun .member ((V0 node) (V1 nset)) Bool (! (member V0 V1) :global true))

(define-fun .prop () Bool (! 
 (let (($v ((forall N,M. (__isleader(N) & __isleader(M)) -> N = M))
 ))
 (and $v))
 :invar-property 0))

(define-fun .axiom () Bool (! 
 (let (($v ((forall S2,S1. (majority(S1) & majority(S2)) -> (exists N. (member(N,S1) & member(N,S2)))))
 ))
 (and $v))
 :axiom true))

(define-fun .init () Bool (! 
 (let (($v ((forall V1,V0. __voted(V0,V1) <-> false) & (forall V0. __isleader(V0) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:become_leader () Bool (! 
 (let (($v exists V__fml:s,V__fml:n. ((forall V0. isleader(V0) <-> (true if (V0 = V__fml:n) else __isleader(V0))) & majority(V__fml:s) & (forall M. member(M,V__fml:s) -> __voted(M,V__fml:n)))
 ))
 (and $v))
 :action ext:become_leader))

(define-fun .action_ext:vote () Bool (! 
 (let (($v exists V__fml:v,V__fml:n. ((forall V1,V0. voted(V0,V1) <-> (true if (V0 = V__fml:v & V1 = V__fml:n) else __voted(V0,V1))) & (forall M. ~__voted(V__fml:v,M)))
 ))
 (and $v))
 :action ext:vote))

