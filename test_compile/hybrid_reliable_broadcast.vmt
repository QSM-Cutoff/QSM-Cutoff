(declare-sort node 0)
(declare-sort quorum_a 0)
(declare-sort quorum_b 0)

(define-fun .node ((S node)) node (! S :sort 0))
(define-fun .quorum_a ((S quorum_a)) quorum_a (! S :sort 0))
(define-fun .quorum_b ((S quorum_b)) quorum_b (! S :sort 0))




(declare-fun __accept (node) Bool)
(declare-fun __fml:nondet () Bool)
(declare-fun __rcv_msg (node node) Bool)
(declare-fun __sentMsgAt (node) Bool)
(declare-fun __sent_msg (node node) Bool)
(declare-fun __sent_msg_proj (node) Bool)
(declare-fun accept (node) Bool)
(declare-fun accepted () Bool)
(declare-fun chosenAtA (node) Bool)
(declare-fun chosenAtB (node) Bool)
(declare-fun member_a (node quorum_a) Bool)
(declare-fun member_b (node quorum_b) Bool)
(declare-fun member_fa (node) Bool)
(declare-fun member_fc (node) Bool)
(declare-fun member_fi (node) Bool)
(declare-fun member_fs (node) Bool)
(declare-fun rcv_init (node) Bool)
(declare-fun rcv_msg (node node) Bool)
(declare-fun received_init () Bool)
(declare-fun sent_msg (node node) Bool)
(declare-fun sent_msg_proj (node) Bool)

(define-fun .def_accepted () Bool (! 
 (let (($v accepted = (exists N. (~member_fs(N) & ~member_fa(N) & accept(N)))
 ))
 (and $v))
 :definition accepted))

(define-fun .def_accepted () Bool (! 
 (let (($v accepted = (exists N. (~member_fs(N) & ~member_fa(N) & accept(N)))
 ))
 (and $v))
 :definition accepted))

(define-fun .def_chosenAtA () Bool (! 
 (let (($v forall V0. chosenAtA(V0) = (exists A. (forall N. member_a(N,A) -> rcv_msg(N,V0)))
 ))
 (and $v))
 :definition chosenAtA))

(define-fun .def_chosenAtA () Bool (! 
 (let (($v forall V0. chosenAtA(V0) = (exists A. (forall N. member_a(N,A) -> rcv_msg(N,V0)))
 ))
 (and $v))
 :definition chosenAtA))

(define-fun .def_chosenAtB () Bool (! 
 (let (($v forall V0. chosenAtB(V0) = (exists B. (forall N. member_b(N,B) -> rcv_msg(N,V0)))
 ))
 (and $v))
 :definition chosenAtB))

(define-fun .def_chosenAtB () Bool (! 
 (let (($v forall V0. chosenAtB(V0) = (exists B. (forall N. member_b(N,B) -> rcv_msg(N,V0)))
 ))
 (and $v))
 :definition chosenAtB))

(define-fun .def_received_init () Bool (! 
 (let (($v received_init = (exists M. (~member_fs(M) & ~member_fa(M) & rcv_init(M)))
 ))
 (and $v))
 :definition received_init))

(define-fun .def_received_init () Bool (! 
 (let (($v received_init = (exists M. (~member_fs(M) & ~member_fa(M) & rcv_init(M)))
 ))
 (and $v))
 :definition received_init))

(define-fun .def_sentMsgAt () Bool (! 
 (let (($v forall V0. sentMsgAt(V0) = (exists D. sent_msg(V0,D))
 ))
 (and $v))
 :definition sentMsgAt))

(define-fun .def_sentMsgAt () Bool (! 
 (let (($v forall V0. sentMsgAt(V0) = (exists D. sent_msg(V0,D))
 ))
 (and $v))
 :definition sentMsgAt))

(define-fun .prop () Bool (! 
 (let (($v ((accepted -> received_init))
 ))
 (and $v))
 :invar-property 0))

(define-fun .axiom () Bool (! 
 (let (($v ((exists B. (forall N. member_b(N,B) -> (~member_fa(N) & ~member_fc(N) & ~member_fs(N) & ~member_fi(N)))) & (forall A_BP. (exists N. (member_a(N,A_BP) & ~member_fa(N) & ~member_fs(N)))) & (forall B_CF. (exists A. (forall N. member_a(N,A) -> (member_b(N,B_CF) & ~member_fa(N) & ~member_fi(N))))) & (forall N. ~(member_fc(N) & member_fi(N))) & (forall N. ~(member_fc(N) & member_fs(N))) & (forall N. ~(member_fc(N) & member_fa(N))) & (forall N. ~(member_fi(N) & member_fs(N))) & (forall N. ~(member_fi(N) & member_fa(N))) & (forall N. ~(member_fs(N) & member_fa(N))))
 ))
 (and $v))
 :axiom true))

(define-fun .init () Bool (! 
 (let (($v ((forall V0. accept(V0) <-> false) & (forall V1,V0. sent_msg(V0,V1) <-> false) & (forall V0. sent_msg_proj(V0) <-> false) & (forall V1,V0. rcv_msg(V0,V1) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:faulty_send_a () Bool (! 
 (let (($v exists V__fml:n. ((forall V0. sent_msg_proj(V0) <-> ((__sentMsgAt(V__fml:n) | __fml:nondet) if (V0 = V__fml:n) else __sent_msg_proj(V0))) & (forall V1,V0. sent_msg(V0,V1) <-> ((__sent_msg(V__fml:n,V1) | __fml:nondet) if (V0 = V__fml:n) else __sent_msg(V0,V1))) & member_fa(V__fml:n))
 ))
 (and $v))
 :action ext:faulty_send_a))

(define-fun .action_ext:faulty_send_s () Bool (! 
 (let (($v exists V__fml:n. ((forall V1,V0. sent_msg(V0,V1) <-> (true if (V0 = V__fml:n) else __sent_msg(V0,V1))) & (forall V0. sent_msg_proj(V0) <-> (true if (V0 = V__fml:n) else __sent_msg_proj(V0))) & member_fs(V__fml:n))
 ))
 (and $v))
 :action ext:faulty_send_s))

(define-fun .action_ext:faulty_state_sa () Bool (! 
 (let (($v exists V__fml:n. ((member_fs(V__fml:n) | member_fa(V__fml:n)) & (forall X1,X0. ~rcv_msg(X0,X1) | __rcv_msg(X0,X1) | X1 = V__fml:n) & (forall X1,X0. rcv_msg(X0,X1) | ~__rcv_msg(X0,X1) | X1 = V__fml:n) & (forall X0. ~accept(X0) | __accept(X0) | X0 = V__fml:n) & (forall X0. accept(X0) | ~__accept(X0) | X0 = V__fml:n))
 ))
 (and $v))
 :action ext:faulty_state_sa))

(define-fun .action_ext:receive_init () Bool (! 
 (let (($v exists V__fml:n. ((forall V1,V0. sent_msg(V0,V1) <-> (true if (V0 = V__fml:n) else __sent_msg(V0,V1))) & (forall V0. sent_msg_proj(V0) <-> (true if (V0 = V__fml:n) else __sent_msg_proj(V0))) & rcv_init(V__fml:n))
 ))
 (and $v))
 :action ext:receive_init))

(define-fun .action_ext:receive_init_i () Bool (! 
 (let (($v exists V__fml:n. ((forall V0. sent_msg_proj(V0) <-> ((__sentMsgAt(V__fml:n) | __fml:nondet) if (V0 = V__fml:n) else __sent_msg_proj(V0))) & (forall V1,V0. sent_msg(V0,V1) <-> ((__sent_msg(V__fml:n,V1) | __fml:nondet) if (V0 = V__fml:n) else __sent_msg(V0,V1))) & member_fi(V__fml:n) & rcv_init(V__fml:n))
 ))
 (and $v))
 :action ext:receive_init_i))

(define-fun .action_ext:receive_msg () Bool (! 
 (let (($v exists V__fml:n,V__fml:s. ((forall V1,V0. rcv_msg(V0,V1) <-> (true if (V0 = V__fml:s & V1 = V__fml:n) else __rcv_msg(V0,V1))) & (forall V0. accept(V0) <-> ((__accept(V__fml:n) | chosenAtB(V__fml:n)) if (V0 = V__fml:n) else __accept(V0))) & (forall V1,V0. sent_msg(V0,V1) <-> ((__sent_msg(V__fml:n,V1) | chosenAtA(V__fml:n)) if (V0 = V__fml:n) else __sent_msg(V0,V1))) & (forall V0. sent_msg_proj(V0) <-> ((__sent_msg_proj(V__fml:n) | chosenAtA(V__fml:n)) if (V0 = V__fml:n) else __sent_msg_proj(V0))) & __sent_msg(V__fml:s,V__fml:n))
 ))
 (and $v))
 :action ext:receive_msg))

(define-fun .action_ext:receive_msg_c () Bool (! 
 (let (($v exists V__fml:n,V__fml:s. ((forall V1,V0. rcv_msg(V0,V1) <-> (true if (V0 = V__fml:s & V1 = V__fml:n) else __rcv_msg(V0,V1))) & (forall V0. accept(V0) <-> ((__accept(V__fml:n) | chosenAtB(V__fml:n)) if (V0 = V__fml:n) else __accept(V0))) & (forall V1,V0. sent_msg(V0,V1) <-> ((__sent_msg(V__fml:n,V1) | (__fml:nondet & chosenAtA(V__fml:n))) if (V0 = V__fml:n) else __sent_msg(V0,V1))) & (forall V0. sent_msg_proj(V0) <-> ((__sent_msg_proj(V__fml:n) | (__fml:nondet & chosenAtA(V__fml:n))) if (V0 = V__fml:n) else __sent_msg_proj(V0))) & member_fc(V__fml:n) & __sent_msg(V__fml:s,V__fml:n))
 ))
 (and $v))
 :action ext:receive_msg_c))

(define-fun .action_ext:receive_msg_i () Bool (! 
 (let (($v exists V__fml:n,V__fml:s. ((forall V1,V0. rcv_msg(V0,V1) <-> (true if (V0 = V__fml:s & V1 = V__fml:n) else __rcv_msg(V0,V1))) & (forall V0. accept(V0) <-> ((__accept(V__fml:n) | chosenAtB(V__fml:n)) if (V0 = V__fml:n) else __accept(V0))) & (forall V0. sent_msg_proj(V0) <-> ((__sentMsgAt(V__fml:n) | (__fml:nondet & chosenAtA(V__fml:n))) if (V0 = V__fml:n) else __sent_msg_proj(V0))) & (forall V1,V0. sent_msg(V0,V1) <-> ((__sent_msg(V__fml:n,V1) | (__fml:nondet & chosenAtA(V__fml:n))) if (V0 = V__fml:n) else __sent_msg(V0,V1))) & member_fi(V__fml:n) & __sent_msg(V__fml:s,V__fml:n))
 ))
 (and $v))
 :action ext:receive_msg_i))

