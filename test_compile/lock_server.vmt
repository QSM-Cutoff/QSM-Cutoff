(declare-sort client 0)
(declare-sort server 0)

(define-fun .client ((S client)) client (! S :sort 0))
(define-fun .server ((S server)) server (! S :sort 0))




(declare-fun __link (client server) Bool)
(declare-fun __semaphore (server) Bool)
(declare-fun link (client server) Bool)
(declare-fun semaphore (server) Bool)

(define-fun .prop () Bool (! 
 (let (($v ((forall C2,S,C1. (link(C1,S) & link(C2,S)) -> C1 = C2))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v ((forall V0. semaphore(V0) <-> true) & (forall V1,V0. link(V0,V1) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:connect () Bool (! 
 (let (($v exists V__fml:c,V__fml:s. ((forall V1,V0. link(V0,V1) <-> (true if (V0 = V__fml:c & V1 = V__fml:s) else __link(V0,V1))) & (forall V0. semaphore(V0) <-> (false if (V0 = V__fml:s) else __semaphore(V0))) & __semaphore(V__fml:s))
 ))
 (and $v))
 :action ext:connect))

(define-fun .action_ext:disconnect () Bool (! 
 (let (($v exists V__fml:c,V__fml:s. ((forall V1,V0. link(V0,V1) <-> (false if (V0 = V__fml:c & V1 = V__fml:s) else __link(V0,V1))) & (forall V0. semaphore(V0) <-> (true if (V0 = V__fml:s) else __semaphore(V0))) & __link(V__fml:c,V__fml:s))
 ))
 (and $v))
 :action ext:disconnect))

