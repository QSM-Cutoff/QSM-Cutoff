(declare-sort node 0)
(declare-sort packet 0)

(define-fun .node ((S node)) node (! S :sort 0))
(define-fun .packet ((S packet)) packet (! S :sort 0))




(declare-fun __pending (packet node node) Bool)
(declare-fun __route_dom (node node) Bool)
(declare-fun __route_tc (node node node) Bool)
(declare-fun __ts0_a () Bool)
(declare-fun __ts0_a_a () Bool)
(declare-fun dst (packet) node)
(declare-fun link (node node) Bool)
(declare-fun pending (packet node node) Bool)
(declare-fun route_dom (node node) Bool)
(declare-fun route_tc (node node node) Bool)
(declare-fun src (packet) node)

(define-fun .prop () Bool (! 
 (let (($v ((forall N,X. route_tc(N,X,X)) & (forall N,X,Z,Y. (route_tc(N,X,Y) & route_tc(N,Y,Z)) -> route_tc(N,X,Z)) & (forall N,X,Y. (route_tc(N,X,Y) & route_tc(N,Y,X)) -> X = Y) & (forall N,X,Z,Y. (route_tc(N,X,Y) & route_tc(N,X,Z)) -> route_tc(N,Y,Z) | route_tc(N,Z,Y)))
 ))
 (and $v))
 :invar-property 0))

(define-fun .axiom () Bool (! 
 (let (($v ((forall X. ~link(X,X)) & (forall X,Y. ~link(X,Y) | link(Y,X)))
 ))
 (and $v))
 :axiom true))

(define-fun .init () Bool (! 
 (let (($v ((forall V1,V0. route_dom(V0,V1) <-> false) & (forall V1,V0,V2. route_tc(V0,V1,V2) <-> V1 = V2) & (forall V1,V0,V2. pending(V0,V1,V2) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:flood () Bool (! 
 (let (($v exists V__fml:sw0,V__fml:p,V__fml:sw1. ((forall V1,V0. route_dom(V0,V1) <-> ((true if (V0 = src(V__fml:p) & V1 = V__fml:sw1) else __route_dom(V0,V1)) if __ts0_a else __route_dom(V0,V1))) & (forall V1,V0,V2. route_tc(V0,V1,V2) <-> (((__route_tc(src(V__fml:p),V1,V2) | (__route_tc(src(V__fml:p),V1,V__fml:sw1) & __route_tc(src(V__fml:p),V__fml:sw0,V2))) if (V0 = src(V__fml:p)) else __route_tc(V0,V1,V2)) if __ts0_a else __route_tc(V0,V1,V2))) & (__ts0_a <-> (~__route_dom(src(V__fml:p),V__fml:sw1) & src(V__fml:p) ~= V__fml:sw1)) & (forall V1,V0,V2. pending(V0,V1,V2) <-> (((link(V__fml:sw1,V2) & V2 ~= V__fml:sw0) if (V0 = V__fml:p & V1 = V__fml:sw1) else __pending(V0,V1,V2)) if __ts0_a_a else __pending(V0,V1,V2))) & (__ts0_a_a <-> dst(V__fml:p) ~= V__fml:sw1) & __pending(V__fml:p,V__fml:sw0,V__fml:sw1) & ~__route_dom(dst(V__fml:p),V__fml:sw1))
 ))
 (and $v))
 :action ext:flood))

(define-fun .action_ext:new_packet () Bool (! 
 (let (($v exists V__fml:p. ((forall V1,V0,V2. pending(V0,V1,V2) <-> (true if (V0 = V__fml:p & V1 = src(V__fml:p) & V2 = src(V__fml:p)) else __pending(V0,V1,V2))))
 ))
 (and $v))
 :action ext:new_packet))

(define-fun .action_ext:route () Bool (! 
 (let (($v exists V__fml:sw0,V__fml:p,V__fml:sw1,V__fml:sw2. ((forall V1,V0. route_dom(V0,V1) <-> ((true if (V0 = src(V__fml:p) & V1 = V__fml:sw1) else __route_dom(V0,V1)) if __ts0_a else __route_dom(V0,V1))) & (forall V1,V0,V2. route_tc(V0,V1,V2) <-> (((__route_tc(src(V__fml:p),V1,V2) | (__route_tc(src(V__fml:p),V1,V__fml:sw1) & __route_tc(src(V__fml:p),V__fml:sw0,V2))) if (V0 = src(V__fml:p)) else __route_tc(V0,V1,V2)) if __ts0_a else __route_tc(V0,V1,V2))) & (__ts0_a <-> (~__route_dom(src(V__fml:p),V__fml:sw1) & src(V__fml:p) ~= V__fml:sw1)) & (forall V1,V0,V2. pending(V0,V1,V2) <-> ((true if (V0 = V__fml:p & V1 = V__fml:sw1 & V2 = V__fml:sw2) else __pending(V0,V1,V2)) if __ts0_a_a else __pending(V0,V1,V2))) & (__ts0_a_a <-> dst(V__fml:p) ~= V__fml:sw1) & __pending(V__fml:p,V__fml:sw0,V__fml:sw1) & __route_dom(dst(V__fml:p),V__fml:sw1) & __route_tc(dst(V__fml:p),V__fml:sw1,V__fml:sw2) & V__fml:sw1 ~= V__fml:sw2 & (forall Z. (__route_tc(dst(V__fml:p),V__fml:sw1,Z) & V__fml:sw1 ~= Z) -> __route_tc(dst(V__fml:p),V__fml:sw2,Z)))
 ))
 (and $v))
 :action ext:route))

