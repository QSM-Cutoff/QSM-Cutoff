(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))

(declare-fun __has_lock (node) Bool)
(declare-fun __message (node node) Bool)

(declare-fun has_lock (node) Bool)
(declare-fun message (node node) Bool)

(define-fun .has_lock ((V0 node)) Bool (! (__has_lock V0) :next has_lock))
(define-fun .message ((V0 node) (V1 node)) Bool (! (__message V0 V1) :next message))

(declare-fun start_node () node)

(define-fun .start_node () node (! start_node :global true))

(define-fun .prop () Bool (! 
 (let (($v ((forall X,Y. X:node ~= Y -> ~(__has_lock(X) & __has_lock(Y))))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v ((forall V1,V0. __message(V0,V1) <-> false) & (forall V0. __has_lock(V0) <-> V0 = start_node))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:recv () Bool (! 
 (let (($v exists V__fml:src,V__fml:dst. ((forall V1,V0. message(V0,V1) <-> (false if (V0 = V__fml:src & V1 = V__fml:dst) else __message(V0,V1))) & (forall V0. has_lock(V0) <-> (true if (V0 = V__fml:dst) else __has_lock(V0))) & __message(V__fml:src,V__fml:dst))
 ))
 (and $v))
 :action ext:recv))

(define-fun .action_ext:send () Bool (! 
 (let (($v exists V__fml:src,V__fml:dst. ((forall V1,V0. message(V0,V1) <-> (true if (V0 = V__fml:src & V1 = V__fml:dst) else __message(V0,V1))) & (forall V0. has_lock(V0) <-> (false if (V0 = V__fml:src) else __has_lock(V0))) & __has_lock(V__fml:src))
 ))
 (and $v))
 :action ext:send))

