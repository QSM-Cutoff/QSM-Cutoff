(declare-sort node 0)
(declare-sort quorum 0)
(declare-sort value 0)

(define-fun .node ((S node)) node (! S :sort 0))
(define-fun .quorum ((S quorum)) quorum (! S :sort 0))
(define-fun .value ((S value)) value (! S :sort 0))




(declare-fun __decided (node value) Bool)
(declare-fun __fml:nondet () Bool)
(declare-fun __leader (node) Bool)
(declare-fun __vote_msg (node node) Bool)
(declare-fun __vote_request_msg (node node) Bool)
(declare-fun __voted (node) Bool)
(declare-fun __votes (node node) Bool)
(declare-fun chosen (node) Bool)
(declare-fun decided (node value) Bool)
(declare-fun leader (node) Bool)
(declare-fun member (node quorum) Bool)
(declare-fun vote_msg (node node) Bool)
(declare-fun vote_request_msg (node node) Bool)
(declare-fun voted (node) Bool)
(declare-fun votes (node node) Bool)

(define-fun .def_chosen () Bool (! 
 (let (($v forall V0. chosen(V0) = (exists Q. (forall Nv. member(Nv,Q) -> votes(V0,Nv)))
 ))
 (and $v))
 :definition chosen))

(define-fun .def_chosen () Bool (! 
 (let (($v forall V0. chosen(V0) = (exists Q. (forall Nv. member(Nv,Q) -> votes(V0,Nv)))
 ))
 (and $v))
 :definition chosen))

(define-fun .prop () Bool (! 
 (let (($v ((forall V2,N1,V1,N2. (decided(N1,V1) & decided(N2,V2)) -> V1 = V2))
 ))
 (and $v))
 :invar-property 0))

(define-fun .axiom () Bool (! 
 (let (($v ((forall Q2,Q1. (exists N. (member(N,Q1) & member(N,Q2)))))
 ))
 (and $v))
 :axiom true))

(define-fun .init () Bool (! 
 (let (($v ((forall V1,V0. vote_request_msg(V0,V1) <-> false) & (forall V0. voted(V0) <-> false) & (forall V1,V0. vote_msg(V0,V1) <-> false) & (forall V1,V0. votes(V0,V1) <-> false) & (forall V0. leader(V0) <-> false) & (forall V0,V1. decided(V0,V1) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:become_leader () Bool (! 
 (let (($v exists V__fml:n,Vvoting_quorum. ((forall V0. leader(V0) <-> (true if (V0 = V__fml:n) else __leader(V0))) & (forall N. member(N,Vvoting_quorum) -> votes(V__fml:n,N)))
 ))
 (and $v))
 :action ext:become_leader))

(define-fun .action_ext:choose_voting_quorum () Bool (! 
 (let (($v exists V__fml:q,V__fml:sn,Vvoting_quorum. (Vvoting_quorum:quorum = V__fml:q & (forall N. member(N,V__fml:q) -> votes(V__fml:sn,N)) & chosen(V__fml:sn))
 ))
 (and $v))
 :action ext:choose_voting_quorum))

(define-fun .action_ext:decide () Bool (! 
 (let (($v exists V__fml:n,V__fml:v. ((forall V0,V1. decided(V0,V1) <-> (true if (V0 = V__fml:n & V1 = V__fml:v) else __decided(V0,V1))) & leader(V__fml:n) & (forall V. ~__decided(V__fml:n,V)))
 ))
 (and $v))
 :action ext:decide))

(define-fun .action_ext:recv_vote () Bool (! 
 (let (($v exists V__fml:sender,V__fml:n. ((forall V1,V0. votes(V0,V1) <-> (true if (V0 = V__fml:n & V1 = V__fml:sender) else __votes(V0,V1))) & vote_msg(V__fml:sender,V__fml:n))
 ))
 (and $v))
 :action ext:recv_vote))

(define-fun .action_ext:send_request_vote () Bool (! 
 (let (($v exists V__fml:src,V__fml:dst. ((forall V1,V0. vote_request_msg(V0,V1) <-> (true if (V0 = V__fml:src & V1 = V__fml:dst) else __vote_request_msg(V0,V1))))
 ))
 (and $v))
 :action ext:send_request_vote))

(define-fun .action_ext:send_vote () Bool (! 
 (let (($v exists V__fml:src,V__fml:dst. ((forall V1,V0. vote_msg(V0,V1) <-> (true if (V0 = V__fml:src & V1 = V__fml:dst) else __vote_msg(V0,V1))) & (forall V0. voted(V0) <-> (true if (V0 = V__fml:src) else __voted(V0))) & (forall V1,V0. vote_request_msg(V0,V1) <-> (__fml:nondet if (V0 = V__fml:src & V1 = V__fml:dst) else __vote_request_msg(V0,V1))) & ~__voted(V__fml:src) & __vote_request_msg(V__fml:dst,V__fml:src))
 ))
 (and $v))
 :action ext:send_vote))

