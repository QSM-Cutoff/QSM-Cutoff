(declare-sort resource_manager 0)

(define-fun .resource_manager ((S resource_manager)) resource_manager (! S :sort 0))

(declare-fun __aborted (resource_manager) Bool)
(declare-fun __committed (resource_manager) Bool)
(declare-fun __prepared (resource_manager) Bool)
(declare-fun __working (resource_manager) Bool)

(declare-fun aborted (resource_manager) Bool)
(declare-fun committed (resource_manager) Bool)
(declare-fun prepared (resource_manager) Bool)
(declare-fun working (resource_manager) Bool)

(define-fun .aborted ((V0 resource_manager)) Bool (! (__aborted V0) :next aborted))
(define-fun .committed ((V0 resource_manager)) Bool (! (__committed V0) :next committed))
(define-fun .prepared ((V0 resource_manager)) Bool (! (__prepared V0) :next prepared))
(define-fun .working ((V0 resource_manager)) Bool (! (__working V0) :next working))

(define-fun .prop () Bool (! 
 (let (($v ((forall R2,R1. ~(__aborted(R1) & __committed(R2))))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v ((forall V0. __working(V0) <-> true) & (forall V0. __prepared(V0) <-> false) & (forall V0. __committed(V0) <-> false) & (forall V0. __aborted(V0) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:decide_abort () Bool (! 
 (let (($v exists V__fml:rm. ((forall V0. working(V0) <-> (false if (V0 = V__fml:rm) else __working(V0))) & (forall V0. prepared(V0) <-> (false if (V0 = V__fml:rm) else __prepared(V0))) & (forall V0. committed(V0) <-> (false if (V0 = V__fml:rm) else __committed(V0))) & (forall V0. aborted(V0) <-> (true if (V0 = V__fml:rm) else __aborted(V0))) & (__working(V__fml:rm) | __prepared(V__fml:rm)) & (forall R. ~__committed(R)))
 ))
 (and $v))
 :action ext:decide_abort))

(define-fun .action_ext:decide_commit () Bool (! 
 (let (($v exists V__fml:rm. ((forall V0. working(V0) <-> (false if (V0 = V__fml:rm) else __working(V0))) & (forall V0. prepared(V0) <-> (false if (V0 = V__fml:rm) else __prepared(V0))) & (forall V0. committed(V0) <-> (true if (V0 = V__fml:rm) else __committed(V0))) & (forall V0. aborted(V0) <-> (false if (V0 = V__fml:rm) else __aborted(V0))) & __prepared(V__fml:rm) & (forall R. __prepared(R) | __committed(R)))
 ))
 (and $v))
 :action ext:decide_commit))

(define-fun .action_ext:prepare () Bool (! 
 (let (($v exists V__fml:rm. ((forall V0. working(V0) <-> (false if (V0 = V__fml:rm) else __working(V0))) & (forall V0. prepared(V0) <-> (true if (V0 = V__fml:rm) else __prepared(V0))) & (forall V0. committed(V0) <-> (false if (V0 = V__fml:rm) else __committed(V0))) & (forall V0. aborted(V0) <-> (false if (V0 = V__fml:rm) else __aborted(V0))) & __working(V__fml:rm))
 ))
 (and $v))
 :action ext:prepare))

