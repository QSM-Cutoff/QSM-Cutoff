(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))




(declare-fun __grant_msg (node) Bool)
(declare-fun __holds_lock (node) Bool)
(declare-fun __lock_msg (node) Bool)
(declare-fun __server_holds_lock () Bool)
(declare-fun __unlock_msg (node) Bool)
(declare-fun grant_msg (node) Bool)
(declare-fun holds_lock (node) Bool)
(declare-fun lock_msg (node) Bool)
(declare-fun server_holds_lock () Bool)
(declare-fun unlock_msg (node) Bool)

(define-fun .prop () Bool (! 
 (let (($v ((forall N2,N1. (holds_lock(N1) & holds_lock(N2)) -> N1 = N2))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v ((forall V0. lock_msg(V0) <-> false) & (forall V0. grant_msg(V0) <-> false) & (forall V0. unlock_msg(V0) <-> false) & (forall V0. holds_lock(V0) <-> false) & (server_holds_lock <-> true))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:recv_grant () Bool (! 
 (let (($v exists V__fml:n. ((forall V0. grant_msg(V0) <-> (__grant_msg(V0) & V0 ~= V__fml:n)) & (forall V0. holds_lock(V0) <-> (true if (V0 = V__fml:n) else __holds_lock(V0))) & __grant_msg(V__fml:n))
 ))
 (and $v))
 :action ext:recv_grant))

(define-fun .action_ext:recv_lock () Bool (! 
 (let (($v exists V__fml:n. ((server_holds_lock <-> false) & (forall V0. lock_msg(V0) <-> (__lock_msg(V0) & V0 ~= V__fml:n)) & (forall V0. grant_msg(V0) <-> (true if (V0 = V__fml:n) else __grant_msg(V0))) & __server_holds_lock & __lock_msg(V__fml:n))
 ))
 (and $v))
 :action ext:recv_lock))

(define-fun .action_ext:recv_unlock () Bool (! 
 (let (($v exists V__fml:n. ((forall V0. unlock_msg(V0) <-> (__unlock_msg(V0) & V0 ~= V__fml:n)) & (server_holds_lock <-> true) & __unlock_msg(V__fml:n))
 ))
 (and $v))
 :action ext:recv_unlock))

(define-fun .action_ext:send_lock () Bool (! 
 (let (($v exists V__fml:n. ((forall V0. lock_msg(V0) <-> (true if (V0 = V__fml:n) else __lock_msg(V0))))
 ))
 (and $v))
 :action ext:send_lock))

(define-fun .action_ext:unlock () Bool (! 
 (let (($v exists V__fml:n. ((forall V0. holds_lock(V0) <-> (__holds_lock(V0) & V0 ~= V__fml:n)) & (forall V0. unlock_msg(V0) <-> (true if (V0 = V__fml:n) else __unlock_msg(V0))) & __holds_lock(V__fml:n))
 ))
 (and $v))
 :action ext:unlock))

