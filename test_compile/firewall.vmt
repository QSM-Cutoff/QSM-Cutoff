(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))




(declare-fun __allowed_in (node) Bool)
(declare-fun __sent (node node) Bool)
(declare-fun allowed_in (node) Bool)
(declare-fun internal (node) Bool)
(declare-fun sent (node node) Bool)

(define-fun .prop () Bool (! 
 (let (($v ((forall S,D. (sent(S,D) & internal(D)) -> (exists I. (internal(I) & sent(I,S)))))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v ((forall V1,V0. sent(V0,V1) <-> false) & (forall V0. allowed_in(V0) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:send_from_internal () Bool (! 
 (let (($v exists V__fml:src,V__fml:dst. ((forall V1,V0. sent(V0,V1) <-> (true if (V0 = V__fml:src & V1 = V__fml:dst) else __sent(V0,V1))) & (forall V0. allowed_in(V0) <-> (true if (V0 = V__fml:dst) else __allowed_in(V0))) & internal(V__fml:src) & ~internal(V__fml:dst))
 ))
 (and $v))
 :action ext:send_from_internal))

(define-fun .action_ext:send_to_internal () Bool (! 
 (let (($v exists V__fml:dst,V__fml:src. ((forall V1,V0. sent(V0,V1) <-> (true if (V0 = V__fml:src & V1 = V__fml:dst) else __sent(V0,V1))) & ~internal(V__fml:src) & internal(V__fml:dst) & allowed_in(V__fml:src))
 ))
 (and $v))
 :action ext:send_to_internal))

