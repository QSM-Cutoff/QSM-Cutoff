(declare-sort node 0)

(define-fun .node ((S node)) node (! S :sort 0))

(declare-fun __allowed_in (node) Bool)
(declare-fun __sent (node node) Bool)

(declare-fun allowed_in (node) Bool)
(declare-fun sent (node node) Bool)

(define-fun .allowed_in ((V0 node)) Bool (! (__allowed_in V0) :next allowed_in))
(define-fun .sent ((V0 node) (V1 node)) Bool (! (__sent V0 V1) :next sent))

(declare-fun internal (node) Bool)

(define-fun .internal ((V0 node)) Bool (! (internal V0) :global true))

(define-fun .prop () Bool (! 
 (let (($v ((forall S,D. (__sent(S,D) & internal(D)) -> (exists I. (internal(I) & __sent(I,S)))))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v ((forall V1,V0. __sent(V0,V1) <-> false) & (forall V0. __allowed_in(V0) <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:send_from_internal () Bool (! 
 (let (($v exists V__fml:dst,V__fml:src. ((forall V1,V0. sent(V0,V1) <-> (true if (V0 = V__fml:src & V1 = V__fml:dst) else __sent(V0,V1))) & (forall V0. allowed_in(V0) <-> (true if (V0 = V__fml:dst) else __allowed_in(V0))) & internal(V__fml:src) & ~internal(V__fml:dst))
 ))
 (and $v))
 :action ext:send_from_internal))

(define-fun .action_ext:send_to_internal () Bool (! 
 (let (($v exists V__fml:dst,V__fml:src. ((forall V1,V0. sent(V0,V1) <-> (true if (V0 = V__fml:src & V1 = V__fml:dst) else __sent(V0,V1))) & ~internal(V__fml:src) & internal(V__fml:dst) & __allowed_in(V__fml:src))
 ))
 (and $v))
 :action ext:send_to_internal))

