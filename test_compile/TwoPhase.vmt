(declare-sort resource_manager 0)

(define-fun .resource_manager ((S resource_manager)) resource_manager (! S :sort 0))

(declare-fun __aborted (resource_manager) Bool)
(declare-fun __committed (resource_manager) Bool)
(declare-fun __msg_abort () Bool)
(declare-fun __msg_commit () Bool)
(declare-fun __msg_prepared (resource_manager) Bool)
(declare-fun __tm_init () Bool)
(declare-fun __tm_prepared (resource_manager) Bool)
(declare-fun __working (resource_manager) Bool)

(declare-fun aborted (resource_manager) Bool)
(declare-fun committed (resource_manager) Bool)
(declare-fun msg_abort () Bool)
(declare-fun msg_commit () Bool)
(declare-fun msg_prepared (resource_manager) Bool)
(declare-fun tm_init () Bool)
(declare-fun tm_prepared (resource_manager) Bool)
(declare-fun working (resource_manager) Bool)

(define-fun .aborted ((V0 resource_manager)) Bool (! (__aborted V0) :next aborted))
(define-fun .committed ((V0 resource_manager)) Bool (! (__committed V0) :next committed))
(define-fun .msg_abort () Bool (! __msg_abort :next msg_abort))
(define-fun .msg_commit () Bool (! __msg_commit :next msg_commit))
(define-fun .msg_prepared ((V0 resource_manager)) Bool (! (__msg_prepared V0) :next msg_prepared))
(define-fun .tm_init () Bool (! __tm_init :next tm_init))
(define-fun .tm_prepared ((V0 resource_manager)) Bool (! (__tm_prepared V0) :next tm_prepared))
(define-fun .working ((V0 resource_manager)) Bool (! (__working V0) :next working))

(define-fun .prop () Bool (! 
 (let (($v ((forall R2,R1. ~(__aborted(R1) & __committed(R2))))
 ))
 (and $v))
 :invar-property 0))

(define-fun .init () Bool (! 
 (let (($v ((forall V0. __working(V0) <-> true) & (forall V0. __committed(V0) <-> false) & (forall V0. __aborted(V0) <-> false) & (__tm_init <-> true) & (forall V0. __tm_prepared(V0) <-> false) & (forall V0. __msg_prepared(V0) <-> false) & (__msg_commit <-> false) & (__msg_abort <-> false))
 ))
 (and $v))
 :init true))

(define-fun .action_ext:rMChooseToAbort () Bool (! 
 (let (($v exists V__fml:rm. ((forall V0. working(V0) <-> (false if (V0 = V__fml:rm) else __working(V0))) & (forall V0. committed(V0) <-> (false if (V0 = V__fml:rm) else __committed(V0))) & (forall V0. aborted(V0) <-> (true if (V0 = V__fml:rm) else __aborted(V0))) & __working(V__fml:rm))
 ))
 (and $v))
 :action ext:rMChooseToAbort))

(define-fun .action_ext:rMPrepare () Bool (! 
 (let (($v exists V__fml:rm. ((forall V0. working(V0) <-> (false if (V0 = V__fml:rm) else __working(V0))) & (forall V0. committed(V0) <-> (false if (V0 = V__fml:rm) else __committed(V0))) & (forall V0. aborted(V0) <-> (false if (V0 = V__fml:rm) else __aborted(V0))) & (forall V0. msg_prepared(V0) <-> (true if (V0 = V__fml:rm) else __msg_prepared(V0))) & __working(V__fml:rm))
 ))
 (and $v))
 :action ext:rMPrepare))

(define-fun .action_ext:rMRcvAbortMsg () Bool (! 
 (let (($v exists V__fml:rm. ((forall V0. working(V0) <-> (false if (V0 = V__fml:rm) else __working(V0))) & (forall V0. committed(V0) <-> (false if (V0 = V__fml:rm) else __committed(V0))) & (forall V0. aborted(V0) <-> (true if (V0 = V__fml:rm) else __aborted(V0))) & __msg_abort)
 ))
 (and $v))
 :action ext:rMRcvAbortMsg))

(define-fun .action_ext:rMRcvCommitMsg () Bool (! 
 (let (($v exists V__fml:rm. ((forall V0. working(V0) <-> (false if (V0 = V__fml:rm) else __working(V0))) & (forall V0. committed(V0) <-> (true if (V0 = V__fml:rm) else __committed(V0))) & (forall V0. aborted(V0) <-> (false if (V0 = V__fml:rm) else __aborted(V0))) & __msg_commit)
 ))
 (and $v))
 :action ext:rMRcvCommitMsg))

(define-fun .action_ext:tMAbort () Bool (! 
 (let (($v ((tm_init <-> false) & (msg_abort <-> true) & __tm_init)
 ))
 (and $v))
 :action ext:tMAbort))

(define-fun .action_ext:tMCommit () Bool (! 
 (let (($v ((tm_init <-> false) & (msg_commit <-> true) & __tm_init & (forall R. __tm_prepared(R)))
 ))
 (and $v))
 :action ext:tMCommit))

(define-fun .action_ext:tMRcvPrepared () Bool (! 
 (let (($v exists V__fml:rm. ((forall V0. tm_prepared(V0) <-> (true if (V0 = V__fml:rm) else __tm_prepared(V0))) & __tm_init & __msg_prepared(V__fml:rm))
 ))
 (and $v))
 :action ext:tMRcvPrepared))

